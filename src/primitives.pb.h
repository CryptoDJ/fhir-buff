// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: primitives.proto

#ifndef PROTOBUF_primitives_2eproto__INCLUDED
#define PROTOBUF_primitives_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace fhirbuffs {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_primitives_2eproto();
void protobuf_AssignDesc_primitives_2eproto();
void protobuf_ShutdownFile_primitives_2eproto();

class Address;
class CodeableConcept;
class Coding;
class Contact;
class ContactPoint;
class HumanName;
class Identifier;
class Organization;
class Period;

enum Address_AddressUses {
  Address_AddressUses_home = 0,
  Address_AddressUses_work = 1,
  Address_AddressUses_temp = 2,
  Address_AddressUses_old = 3
};
bool Address_AddressUses_IsValid(int value);
const Address_AddressUses Address_AddressUses_AddressUses_MIN = Address_AddressUses_home;
const Address_AddressUses Address_AddressUses_AddressUses_MAX = Address_AddressUses_old;
const int Address_AddressUses_AddressUses_ARRAYSIZE = Address_AddressUses_AddressUses_MAX + 1;

const ::google::protobuf::EnumDescriptor* Address_AddressUses_descriptor();
inline const ::std::string& Address_AddressUses_Name(Address_AddressUses value) {
  return ::google::protobuf::internal::NameOfEnum(
    Address_AddressUses_descriptor(), value);
}
inline bool Address_AddressUses_Parse(
    const ::std::string& name, Address_AddressUses* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Address_AddressUses>(
    Address_AddressUses_descriptor(), name, value);
}
enum Address_AddressTypes {
  Address_AddressTypes_postal = 0,
  Address_AddressTypes_physical = 1,
  Address_AddressTypes_both = 2
};
bool Address_AddressTypes_IsValid(int value);
const Address_AddressTypes Address_AddressTypes_AddressTypes_MIN = Address_AddressTypes_postal;
const Address_AddressTypes Address_AddressTypes_AddressTypes_MAX = Address_AddressTypes_both;
const int Address_AddressTypes_AddressTypes_ARRAYSIZE = Address_AddressTypes_AddressTypes_MAX + 1;

const ::google::protobuf::EnumDescriptor* Address_AddressTypes_descriptor();
inline const ::std::string& Address_AddressTypes_Name(Address_AddressTypes value) {
  return ::google::protobuf::internal::NameOfEnum(
    Address_AddressTypes_descriptor(), value);
}
inline bool Address_AddressTypes_Parse(
    const ::std::string& name, Address_AddressTypes* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Address_AddressTypes>(
    Address_AddressTypes_descriptor(), name, value);
}
enum HumanName_HumanNameUses {
  HumanName_HumanNameUses_usual = 0,
  HumanName_HumanNameUses_official = 1,
  HumanName_HumanNameUses_temp = 2,
  HumanName_HumanNameUses_nickname = 3,
  HumanName_HumanNameUses_anonymous = 4,
  HumanName_HumanNameUses_old = 5,
  HumanName_HumanNameUses_maiden = 6
};
bool HumanName_HumanNameUses_IsValid(int value);
const HumanName_HumanNameUses HumanName_HumanNameUses_HumanNameUses_MIN = HumanName_HumanNameUses_usual;
const HumanName_HumanNameUses HumanName_HumanNameUses_HumanNameUses_MAX = HumanName_HumanNameUses_maiden;
const int HumanName_HumanNameUses_HumanNameUses_ARRAYSIZE = HumanName_HumanNameUses_HumanNameUses_MAX + 1;

const ::google::protobuf::EnumDescriptor* HumanName_HumanNameUses_descriptor();
inline const ::std::string& HumanName_HumanNameUses_Name(HumanName_HumanNameUses value) {
  return ::google::protobuf::internal::NameOfEnum(
    HumanName_HumanNameUses_descriptor(), value);
}
inline bool HumanName_HumanNameUses_Parse(
    const ::std::string& name, HumanName_HumanNameUses* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HumanName_HumanNameUses>(
    HumanName_HumanNameUses_descriptor(), name, value);
}
enum ContactPoint_AuthorReferences {
  ContactPoint_AuthorReferences_Practitioner = 0,
  ContactPoint_AuthorReferences_Patient = 1,
  ContactPoint_AuthorReferences_RelatedPerson = 2,
  ContactPoint_AuthorReferences_Other = 3
};
bool ContactPoint_AuthorReferences_IsValid(int value);
const ContactPoint_AuthorReferences ContactPoint_AuthorReferences_AuthorReferences_MIN = ContactPoint_AuthorReferences_Practitioner;
const ContactPoint_AuthorReferences ContactPoint_AuthorReferences_AuthorReferences_MAX = ContactPoint_AuthorReferences_Other;
const int ContactPoint_AuthorReferences_AuthorReferences_ARRAYSIZE = ContactPoint_AuthorReferences_AuthorReferences_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContactPoint_AuthorReferences_descriptor();
inline const ::std::string& ContactPoint_AuthorReferences_Name(ContactPoint_AuthorReferences value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContactPoint_AuthorReferences_descriptor(), value);
}
inline bool ContactPoint_AuthorReferences_Parse(
    const ::std::string& name, ContactPoint_AuthorReferences* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContactPoint_AuthorReferences>(
    ContactPoint_AuthorReferences_descriptor(), name, value);
}
enum Identifier_IdentifierUses {
  Identifier_IdentifierUses_Usual = 0,
  Identifier_IdentifierUses_Official = 1,
  Identifier_IdentifierUses_Temp = 2,
  Identifier_IdentifierUses_Secondary = 3,
  Identifier_IdentifierUses_Unknown = 4,
  Identifier_IdentifierUses_Other = 5
};
bool Identifier_IdentifierUses_IsValid(int value);
const Identifier_IdentifierUses Identifier_IdentifierUses_IdentifierUses_MIN = Identifier_IdentifierUses_Usual;
const Identifier_IdentifierUses Identifier_IdentifierUses_IdentifierUses_MAX = Identifier_IdentifierUses_Other;
const int Identifier_IdentifierUses_IdentifierUses_ARRAYSIZE = Identifier_IdentifierUses_IdentifierUses_MAX + 1;

const ::google::protobuf::EnumDescriptor* Identifier_IdentifierUses_descriptor();
inline const ::std::string& Identifier_IdentifierUses_Name(Identifier_IdentifierUses value) {
  return ::google::protobuf::internal::NameOfEnum(
    Identifier_IdentifierUses_descriptor(), value);
}
inline bool Identifier_IdentifierUses_Parse(
    const ::std::string& name, Identifier_IdentifierUses* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Identifier_IdentifierUses>(
    Identifier_IdentifierUses_descriptor(), name, value);
}
// ===================================================================

class Coding : public ::google::protobuf::Message {
 public:
  Coding();
  virtual ~Coding();

  Coding(const Coding& from);

  inline Coding& operator=(const Coding& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Coding& default_instance();

  void Swap(Coding* other);

  // implements Message ----------------------------------------------

  inline Coding* New() const { return New(NULL); }

  Coding* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Coding& from);
  void MergeFrom(const Coding& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Coding* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string system = 1;
  bool has_system() const;
  void clear_system();
  static const int kSystemFieldNumber = 1;
  const ::std::string& system() const;
  void set_system(const ::std::string& value);
  void set_system(const char* value);
  void set_system(const char* value, size_t size);
  ::std::string* mutable_system();
  ::std::string* release_system();
  void set_allocated_system(::std::string* system);

  // required string version = 2;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // required string code = 3;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 3;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // required string display = 4;
  bool has_display() const;
  void clear_display();
  static const int kDisplayFieldNumber = 4;
  const ::std::string& display() const;
  void set_display(const ::std::string& value);
  void set_display(const char* value);
  void set_display(const char* value, size_t size);
  ::std::string* mutable_display();
  ::std::string* release_display();
  void set_allocated_display(::std::string* display);

  // required bool userSelected = 5;
  bool has_userselected() const;
  void clear_userselected();
  static const int kUserSelectedFieldNumber = 5;
  bool userselected() const;
  void set_userselected(bool value);

  // @@protoc_insertion_point(class_scope:fhirbuffs.Coding)
 private:
  inline void set_has_system();
  inline void clear_has_system();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_display();
  inline void clear_has_display();
  inline void set_has_userselected();
  inline void clear_has_userselected();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr system_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  ::google::protobuf::internal::ArenaStringPtr display_;
  bool userselected_;
  friend void  protobuf_AddDesc_primitives_2eproto();
  friend void protobuf_AssignDesc_primitives_2eproto();
  friend void protobuf_ShutdownFile_primitives_2eproto();

  void InitAsDefaultInstance();
  static Coding* default_instance_;
};
// -------------------------------------------------------------------

class CodeableConcept : public ::google::protobuf::Message {
 public:
  CodeableConcept();
  virtual ~CodeableConcept();

  CodeableConcept(const CodeableConcept& from);

  inline CodeableConcept& operator=(const CodeableConcept& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CodeableConcept& default_instance();

  void Swap(CodeableConcept* other);

  // implements Message ----------------------------------------------

  inline CodeableConcept* New() const { return New(NULL); }

  CodeableConcept* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CodeableConcept& from);
  void MergeFrom(const CodeableConcept& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CodeableConcept* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fhirbuffs.Coding coding = 1;
  int coding_size() const;
  void clear_coding();
  static const int kCodingFieldNumber = 1;
  const ::fhirbuffs::Coding& coding(int index) const;
  ::fhirbuffs::Coding* mutable_coding(int index);
  ::fhirbuffs::Coding* add_coding();
  ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Coding >*
      mutable_coding();
  const ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Coding >&
      coding() const;

  // required string text = 2;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:fhirbuffs.CodeableConcept)
 private:
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Coding > coding_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  friend void  protobuf_AddDesc_primitives_2eproto();
  friend void protobuf_AssignDesc_primitives_2eproto();
  friend void protobuf_ShutdownFile_primitives_2eproto();

  void InitAsDefaultInstance();
  static CodeableConcept* default_instance_;
};
// -------------------------------------------------------------------

class Period : public ::google::protobuf::Message {
 public:
  Period();
  virtual ~Period();

  Period(const Period& from);

  inline Period& operator=(const Period& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Period& default_instance();

  void Swap(Period* other);

  // implements Message ----------------------------------------------

  inline Period* New() const { return New(NULL); }

  Period* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Period& from);
  void MergeFrom(const Period& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Period* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 start = 1;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 1;
  ::google::protobuf::int64 start() const;
  void set_start(::google::protobuf::int64 value);

  // required int64 end = 2;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 2;
  ::google::protobuf::int64 end() const;
  void set_end(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:fhirbuffs.Period)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 start_;
  ::google::protobuf::int64 end_;
  friend void  protobuf_AddDesc_primitives_2eproto();
  friend void protobuf_AssignDesc_primitives_2eproto();
  friend void protobuf_ShutdownFile_primitives_2eproto();

  void InitAsDefaultInstance();
  static Period* default_instance_;
};
// -------------------------------------------------------------------

class Address : public ::google::protobuf::Message {
 public:
  Address();
  virtual ~Address();

  Address(const Address& from);

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Address& default_instance();

  void Swap(Address* other);

  // implements Message ----------------------------------------------

  inline Address* New() const { return New(NULL); }

  Address* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Address& from);
  void MergeFrom(const Address& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Address* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Address_AddressUses AddressUses;
  static const AddressUses home = Address_AddressUses_home;
  static const AddressUses work = Address_AddressUses_work;
  static const AddressUses temp = Address_AddressUses_temp;
  static const AddressUses old = Address_AddressUses_old;
  static inline bool AddressUses_IsValid(int value) {
    return Address_AddressUses_IsValid(value);
  }
  static const AddressUses AddressUses_MIN =
    Address_AddressUses_AddressUses_MIN;
  static const AddressUses AddressUses_MAX =
    Address_AddressUses_AddressUses_MAX;
  static const int AddressUses_ARRAYSIZE =
    Address_AddressUses_AddressUses_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AddressUses_descriptor() {
    return Address_AddressUses_descriptor();
  }
  static inline const ::std::string& AddressUses_Name(AddressUses value) {
    return Address_AddressUses_Name(value);
  }
  static inline bool AddressUses_Parse(const ::std::string& name,
      AddressUses* value) {
    return Address_AddressUses_Parse(name, value);
  }

  typedef Address_AddressTypes AddressTypes;
  static const AddressTypes postal = Address_AddressTypes_postal;
  static const AddressTypes physical = Address_AddressTypes_physical;
  static const AddressTypes both = Address_AddressTypes_both;
  static inline bool AddressTypes_IsValid(int value) {
    return Address_AddressTypes_IsValid(value);
  }
  static const AddressTypes AddressTypes_MIN =
    Address_AddressTypes_AddressTypes_MIN;
  static const AddressTypes AddressTypes_MAX =
    Address_AddressTypes_AddressTypes_MAX;
  static const int AddressTypes_ARRAYSIZE =
    Address_AddressTypes_AddressTypes_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AddressTypes_descriptor() {
    return Address_AddressTypes_descriptor();
  }
  static inline const ::std::string& AddressTypes_Name(AddressTypes value) {
    return Address_AddressTypes_Name(value);
  }
  static inline bool AddressTypes_Parse(const ::std::string& name,
      AddressTypes* value) {
    return Address_AddressTypes_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .fhirbuffs.Address.AddressUses use = 1;
  bool has_use() const;
  void clear_use();
  static const int kUseFieldNumber = 1;
  ::fhirbuffs::Address_AddressUses use() const;
  void set_use(::fhirbuffs::Address_AddressUses value);

  // required .fhirbuffs.Address.AddressTypes type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::fhirbuffs::Address_AddressTypes type() const;
  void set_type(::fhirbuffs::Address_AddressTypes value);

  // required string text = 3;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 3;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // repeated string line = 4;
  int line_size() const;
  void clear_line();
  static const int kLineFieldNumber = 4;
  const ::std::string& line(int index) const;
  ::std::string* mutable_line(int index);
  void set_line(int index, const ::std::string& value);
  void set_line(int index, const char* value);
  void set_line(int index, const char* value, size_t size);
  ::std::string* add_line();
  void add_line(const ::std::string& value);
  void add_line(const char* value);
  void add_line(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& line() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_line();

  // required string city = 5;
  bool has_city() const;
  void clear_city();
  static const int kCityFieldNumber = 5;
  const ::std::string& city() const;
  void set_city(const ::std::string& value);
  void set_city(const char* value);
  void set_city(const char* value, size_t size);
  ::std::string* mutable_city();
  ::std::string* release_city();
  void set_allocated_city(::std::string* city);

  // required string district = 6;
  bool has_district() const;
  void clear_district();
  static const int kDistrictFieldNumber = 6;
  const ::std::string& district() const;
  void set_district(const ::std::string& value);
  void set_district(const char* value);
  void set_district(const char* value, size_t size);
  ::std::string* mutable_district();
  ::std::string* release_district();
  void set_allocated_district(::std::string* district);

  // required string state = 7;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 7;
  const ::std::string& state() const;
  void set_state(const ::std::string& value);
  void set_state(const char* value);
  void set_state(const char* value, size_t size);
  ::std::string* mutable_state();
  ::std::string* release_state();
  void set_allocated_state(::std::string* state);

  // required string postalCode = 8;
  bool has_postalcode() const;
  void clear_postalcode();
  static const int kPostalCodeFieldNumber = 8;
  const ::std::string& postalcode() const;
  void set_postalcode(const ::std::string& value);
  void set_postalcode(const char* value);
  void set_postalcode(const char* value, size_t size);
  ::std::string* mutable_postalcode();
  ::std::string* release_postalcode();
  void set_allocated_postalcode(::std::string* postalcode);

  // required string country = 9;
  bool has_country() const;
  void clear_country();
  static const int kCountryFieldNumber = 9;
  const ::std::string& country() const;
  void set_country(const ::std::string& value);
  void set_country(const char* value);
  void set_country(const char* value, size_t size);
  ::std::string* mutable_country();
  ::std::string* release_country();
  void set_allocated_country(::std::string* country);

  // required .fhirbuffs.Period period = 10;
  bool has_period() const;
  void clear_period();
  static const int kPeriodFieldNumber = 10;
  const ::fhirbuffs::Period& period() const;
  ::fhirbuffs::Period* mutable_period();
  ::fhirbuffs::Period* release_period();
  void set_allocated_period(::fhirbuffs::Period* period);

  // @@protoc_insertion_point(class_scope:fhirbuffs.Address)
 private:
  inline void set_has_use();
  inline void clear_has_use();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_district();
  inline void clear_has_district();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_postalcode();
  inline void clear_has_postalcode();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_period();
  inline void clear_has_period();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int use_;
  int type_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::RepeatedPtrField< ::std::string> line_;
  ::google::protobuf::internal::ArenaStringPtr city_;
  ::google::protobuf::internal::ArenaStringPtr district_;
  ::google::protobuf::internal::ArenaStringPtr state_;
  ::google::protobuf::internal::ArenaStringPtr postalcode_;
  ::google::protobuf::internal::ArenaStringPtr country_;
  ::fhirbuffs::Period* period_;
  friend void  protobuf_AddDesc_primitives_2eproto();
  friend void protobuf_AssignDesc_primitives_2eproto();
  friend void protobuf_ShutdownFile_primitives_2eproto();

  void InitAsDefaultInstance();
  static Address* default_instance_;
};
// -------------------------------------------------------------------

class HumanName : public ::google::protobuf::Message {
 public:
  HumanName();
  virtual ~HumanName();

  HumanName(const HumanName& from);

  inline HumanName& operator=(const HumanName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HumanName& default_instance();

  void Swap(HumanName* other);

  // implements Message ----------------------------------------------

  inline HumanName* New() const { return New(NULL); }

  HumanName* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HumanName& from);
  void MergeFrom(const HumanName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HumanName* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef HumanName_HumanNameUses HumanNameUses;
  static const HumanNameUses usual = HumanName_HumanNameUses_usual;
  static const HumanNameUses official = HumanName_HumanNameUses_official;
  static const HumanNameUses temp = HumanName_HumanNameUses_temp;
  static const HumanNameUses nickname = HumanName_HumanNameUses_nickname;
  static const HumanNameUses anonymous = HumanName_HumanNameUses_anonymous;
  static const HumanNameUses old = HumanName_HumanNameUses_old;
  static const HumanNameUses maiden = HumanName_HumanNameUses_maiden;
  static inline bool HumanNameUses_IsValid(int value) {
    return HumanName_HumanNameUses_IsValid(value);
  }
  static const HumanNameUses HumanNameUses_MIN =
    HumanName_HumanNameUses_HumanNameUses_MIN;
  static const HumanNameUses HumanNameUses_MAX =
    HumanName_HumanNameUses_HumanNameUses_MAX;
  static const int HumanNameUses_ARRAYSIZE =
    HumanName_HumanNameUses_HumanNameUses_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HumanNameUses_descriptor() {
    return HumanName_HumanNameUses_descriptor();
  }
  static inline const ::std::string& HumanNameUses_Name(HumanNameUses value) {
    return HumanName_HumanNameUses_Name(value);
  }
  static inline bool HumanNameUses_Parse(const ::std::string& name,
      HumanNameUses* value) {
    return HumanName_HumanNameUses_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .fhirbuffs.HumanName.HumanNameUses use = 1;
  bool has_use() const;
  void clear_use();
  static const int kUseFieldNumber = 1;
  ::fhirbuffs::HumanName_HumanNameUses use() const;
  void set_use(::fhirbuffs::HumanName_HumanNameUses value);

  // required string text = 2;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // repeated string family = 3;
  int family_size() const;
  void clear_family();
  static const int kFamilyFieldNumber = 3;
  const ::std::string& family(int index) const;
  ::std::string* mutable_family(int index);
  void set_family(int index, const ::std::string& value);
  void set_family(int index, const char* value);
  void set_family(int index, const char* value, size_t size);
  ::std::string* add_family();
  void add_family(const ::std::string& value);
  void add_family(const char* value);
  void add_family(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& family() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_family();

  // repeated string given = 4;
  int given_size() const;
  void clear_given();
  static const int kGivenFieldNumber = 4;
  const ::std::string& given(int index) const;
  ::std::string* mutable_given(int index);
  void set_given(int index, const ::std::string& value);
  void set_given(int index, const char* value);
  void set_given(int index, const char* value, size_t size);
  ::std::string* add_given();
  void add_given(const ::std::string& value);
  void add_given(const char* value);
  void add_given(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& given() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_given();

  // repeated string prefix = 5;
  int prefix_size() const;
  void clear_prefix();
  static const int kPrefixFieldNumber = 5;
  const ::std::string& prefix(int index) const;
  ::std::string* mutable_prefix(int index);
  void set_prefix(int index, const ::std::string& value);
  void set_prefix(int index, const char* value);
  void set_prefix(int index, const char* value, size_t size);
  ::std::string* add_prefix();
  void add_prefix(const ::std::string& value);
  void add_prefix(const char* value);
  void add_prefix(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& prefix() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_prefix();

  // repeated string suffix = 6;
  int suffix_size() const;
  void clear_suffix();
  static const int kSuffixFieldNumber = 6;
  const ::std::string& suffix(int index) const;
  ::std::string* mutable_suffix(int index);
  void set_suffix(int index, const ::std::string& value);
  void set_suffix(int index, const char* value);
  void set_suffix(int index, const char* value, size_t size);
  ::std::string* add_suffix();
  void add_suffix(const ::std::string& value);
  void add_suffix(const char* value);
  void add_suffix(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& suffix() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_suffix();

  // required .fhirbuffs.Period period = 7;
  bool has_period() const;
  void clear_period();
  static const int kPeriodFieldNumber = 7;
  const ::fhirbuffs::Period& period() const;
  ::fhirbuffs::Period* mutable_period();
  ::fhirbuffs::Period* release_period();
  void set_allocated_period(::fhirbuffs::Period* period);

  // @@protoc_insertion_point(class_scope:fhirbuffs.HumanName)
 private:
  inline void set_has_use();
  inline void clear_has_use();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_period();
  inline void clear_has_period();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::RepeatedPtrField< ::std::string> family_;
  ::google::protobuf::RepeatedPtrField< ::std::string> given_;
  ::google::protobuf::RepeatedPtrField< ::std::string> prefix_;
  ::google::protobuf::RepeatedPtrField< ::std::string> suffix_;
  ::fhirbuffs::Period* period_;
  int use_;
  friend void  protobuf_AddDesc_primitives_2eproto();
  friend void protobuf_AssignDesc_primitives_2eproto();
  friend void protobuf_ShutdownFile_primitives_2eproto();

  void InitAsDefaultInstance();
  static HumanName* default_instance_;
};
// -------------------------------------------------------------------

class ContactPoint : public ::google::protobuf::Message {
 public:
  ContactPoint();
  virtual ~ContactPoint();

  ContactPoint(const ContactPoint& from);

  inline ContactPoint& operator=(const ContactPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactPoint& default_instance();

  void Swap(ContactPoint* other);

  // implements Message ----------------------------------------------

  inline ContactPoint* New() const { return New(NULL); }

  ContactPoint* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContactPoint& from);
  void MergeFrom(const ContactPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContactPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ContactPoint_AuthorReferences AuthorReferences;
  static const AuthorReferences Practitioner = ContactPoint_AuthorReferences_Practitioner;
  static const AuthorReferences Patient = ContactPoint_AuthorReferences_Patient;
  static const AuthorReferences RelatedPerson = ContactPoint_AuthorReferences_RelatedPerson;
  static const AuthorReferences Other = ContactPoint_AuthorReferences_Other;
  static inline bool AuthorReferences_IsValid(int value) {
    return ContactPoint_AuthorReferences_IsValid(value);
  }
  static const AuthorReferences AuthorReferences_MIN =
    ContactPoint_AuthorReferences_AuthorReferences_MIN;
  static const AuthorReferences AuthorReferences_MAX =
    ContactPoint_AuthorReferences_AuthorReferences_MAX;
  static const int AuthorReferences_ARRAYSIZE =
    ContactPoint_AuthorReferences_AuthorReferences_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AuthorReferences_descriptor() {
    return ContactPoint_AuthorReferences_descriptor();
  }
  static inline const ::std::string& AuthorReferences_Name(AuthorReferences value) {
    return ContactPoint_AuthorReferences_Name(value);
  }
  static inline bool AuthorReferences_Parse(const ::std::string& name,
      AuthorReferences* value) {
    return ContactPoint_AuthorReferences_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .fhirbuffs.ContactPoint.AuthorReferences authorReference = 1;
  bool has_authorreference() const;
  void clear_authorreference();
  static const int kAuthorReferenceFieldNumber = 1;
  ::fhirbuffs::ContactPoint_AuthorReferences authorreference() const;
  void set_authorreference(::fhirbuffs::ContactPoint_AuthorReferences value);

  // required string authorString = 2;
  bool has_authorstring() const;
  void clear_authorstring();
  static const int kAuthorStringFieldNumber = 2;
  const ::std::string& authorstring() const;
  void set_authorstring(const ::std::string& value);
  void set_authorstring(const char* value);
  void set_authorstring(const char* value, size_t size);
  ::std::string* mutable_authorstring();
  ::std::string* release_authorstring();
  void set_allocated_authorstring(::std::string* authorstring);

  // optional int64 time = 3;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  ::google::protobuf::int64 time() const;
  void set_time(::google::protobuf::int64 value);

  // required string text = 4;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 4;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:fhirbuffs.ContactPoint)
 private:
  inline void set_has_authorreference();
  inline void clear_has_authorreference();
  inline void set_has_authorstring();
  inline void clear_has_authorstring();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_text();
  inline void clear_has_text();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr authorstring_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  int authorreference_;
  friend void  protobuf_AddDesc_primitives_2eproto();
  friend void protobuf_AssignDesc_primitives_2eproto();
  friend void protobuf_ShutdownFile_primitives_2eproto();

  void InitAsDefaultInstance();
  static ContactPoint* default_instance_;
};
// -------------------------------------------------------------------

class Contact : public ::google::protobuf::Message {
 public:
  Contact();
  virtual ~Contact();

  Contact(const Contact& from);

  inline Contact& operator=(const Contact& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Contact& default_instance();

  void Swap(Contact* other);

  // implements Message ----------------------------------------------

  inline Contact* New() const { return New(NULL); }

  Contact* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Contact& from);
  void MergeFrom(const Contact& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Contact* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .fhirbuffs.CodeableConcept purpose = 1;
  bool has_purpose() const;
  void clear_purpose();
  static const int kPurposeFieldNumber = 1;
  const ::fhirbuffs::CodeableConcept& purpose() const;
  ::fhirbuffs::CodeableConcept* mutable_purpose();
  ::fhirbuffs::CodeableConcept* release_purpose();
  void set_allocated_purpose(::fhirbuffs::CodeableConcept* purpose);

  // required .fhirbuffs.HumanName name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::fhirbuffs::HumanName& name() const;
  ::fhirbuffs::HumanName* mutable_name();
  ::fhirbuffs::HumanName* release_name();
  void set_allocated_name(::fhirbuffs::HumanName* name);

  // repeated .fhirbuffs.ContactPoint telecom = 3;
  int telecom_size() const;
  void clear_telecom();
  static const int kTelecomFieldNumber = 3;
  const ::fhirbuffs::ContactPoint& telecom(int index) const;
  ::fhirbuffs::ContactPoint* mutable_telecom(int index);
  ::fhirbuffs::ContactPoint* add_telecom();
  ::google::protobuf::RepeatedPtrField< ::fhirbuffs::ContactPoint >*
      mutable_telecom();
  const ::google::protobuf::RepeatedPtrField< ::fhirbuffs::ContactPoint >&
      telecom() const;

  // required .fhirbuffs.Address address = 4;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 4;
  const ::fhirbuffs::Address& address() const;
  ::fhirbuffs::Address* mutable_address();
  ::fhirbuffs::Address* release_address();
  void set_allocated_address(::fhirbuffs::Address* address);

  // @@protoc_insertion_point(class_scope:fhirbuffs.Contact)
 private:
  inline void set_has_purpose();
  inline void clear_has_purpose();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_address();
  inline void clear_has_address();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::fhirbuffs::CodeableConcept* purpose_;
  ::fhirbuffs::HumanName* name_;
  ::google::protobuf::RepeatedPtrField< ::fhirbuffs::ContactPoint > telecom_;
  ::fhirbuffs::Address* address_;
  friend void  protobuf_AddDesc_primitives_2eproto();
  friend void protobuf_AssignDesc_primitives_2eproto();
  friend void protobuf_ShutdownFile_primitives_2eproto();

  void InitAsDefaultInstance();
  static Contact* default_instance_;
};
// -------------------------------------------------------------------

class Identifier : public ::google::protobuf::Message {
 public:
  Identifier();
  virtual ~Identifier();

  Identifier(const Identifier& from);

  inline Identifier& operator=(const Identifier& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Identifier& default_instance();

  void Swap(Identifier* other);

  // implements Message ----------------------------------------------

  inline Identifier* New() const { return New(NULL); }

  Identifier* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Identifier& from);
  void MergeFrom(const Identifier& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Identifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Identifier_IdentifierUses IdentifierUses;
  static const IdentifierUses Usual = Identifier_IdentifierUses_Usual;
  static const IdentifierUses Official = Identifier_IdentifierUses_Official;
  static const IdentifierUses Temp = Identifier_IdentifierUses_Temp;
  static const IdentifierUses Secondary = Identifier_IdentifierUses_Secondary;
  static const IdentifierUses Unknown = Identifier_IdentifierUses_Unknown;
  static const IdentifierUses Other = Identifier_IdentifierUses_Other;
  static inline bool IdentifierUses_IsValid(int value) {
    return Identifier_IdentifierUses_IsValid(value);
  }
  static const IdentifierUses IdentifierUses_MIN =
    Identifier_IdentifierUses_IdentifierUses_MIN;
  static const IdentifierUses IdentifierUses_MAX =
    Identifier_IdentifierUses_IdentifierUses_MAX;
  static const int IdentifierUses_ARRAYSIZE =
    Identifier_IdentifierUses_IdentifierUses_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  IdentifierUses_descriptor() {
    return Identifier_IdentifierUses_descriptor();
  }
  static inline const ::std::string& IdentifierUses_Name(IdentifierUses value) {
    return Identifier_IdentifierUses_Name(value);
  }
  static inline bool IdentifierUses_Parse(const ::std::string& name,
      IdentifierUses* value) {
    return Identifier_IdentifierUses_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .fhirbuffs.Identifier.IdentifierUses use = 1;
  bool has_use() const;
  void clear_use();
  static const int kUseFieldNumber = 1;
  ::fhirbuffs::Identifier_IdentifierUses use() const;
  void set_use(::fhirbuffs::Identifier_IdentifierUses value);

  // repeated .fhirbuffs.CodeableConcept type = 2;
  int type_size() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::fhirbuffs::CodeableConcept& type(int index) const;
  ::fhirbuffs::CodeableConcept* mutable_type(int index);
  ::fhirbuffs::CodeableConcept* add_type();
  ::google::protobuf::RepeatedPtrField< ::fhirbuffs::CodeableConcept >*
      mutable_type();
  const ::google::protobuf::RepeatedPtrField< ::fhirbuffs::CodeableConcept >&
      type() const;

  // required string system = 3;
  bool has_system() const;
  void clear_system();
  static const int kSystemFieldNumber = 3;
  const ::std::string& system() const;
  void set_system(const ::std::string& value);
  void set_system(const char* value);
  void set_system(const char* value, size_t size);
  ::std::string* mutable_system();
  ::std::string* release_system();
  void set_allocated_system(::std::string* system);

  // required string value = 4;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 4;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // required .fhirbuffs.Period period = 5;
  bool has_period() const;
  void clear_period();
  static const int kPeriodFieldNumber = 5;
  const ::fhirbuffs::Period& period() const;
  ::fhirbuffs::Period* mutable_period();
  ::fhirbuffs::Period* release_period();
  void set_allocated_period(::fhirbuffs::Period* period);

  // repeated .fhirbuffs.Organization assigner = 6;
  int assigner_size() const;
  void clear_assigner();
  static const int kAssignerFieldNumber = 6;
  const ::fhirbuffs::Organization& assigner(int index) const;
  ::fhirbuffs::Organization* mutable_assigner(int index);
  ::fhirbuffs::Organization* add_assigner();
  ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Organization >*
      mutable_assigner();
  const ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Organization >&
      assigner() const;

  // @@protoc_insertion_point(class_scope:fhirbuffs.Identifier)
 private:
  inline void set_has_use();
  inline void clear_has_use();
  inline void set_has_system();
  inline void clear_has_system();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_period();
  inline void clear_has_period();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fhirbuffs::CodeableConcept > type_;
  ::google::protobuf::internal::ArenaStringPtr system_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::fhirbuffs::Period* period_;
  ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Organization > assigner_;
  int use_;
  friend void  protobuf_AddDesc_primitives_2eproto();
  friend void protobuf_AssignDesc_primitives_2eproto();
  friend void protobuf_ShutdownFile_primitives_2eproto();

  void InitAsDefaultInstance();
  static Identifier* default_instance_;
};
// -------------------------------------------------------------------

class Organization : public ::google::protobuf::Message {
 public:
  Organization();
  virtual ~Organization();

  Organization(const Organization& from);

  inline Organization& operator=(const Organization& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Organization& default_instance();

  void Swap(Organization* other);

  // implements Message ----------------------------------------------

  inline Organization* New() const { return New(NULL); }

  Organization* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Organization& from);
  void MergeFrom(const Organization& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Organization* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fhirbuffs.Identifier identifier = 1;
  int identifier_size() const;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  const ::fhirbuffs::Identifier& identifier(int index) const;
  ::fhirbuffs::Identifier* mutable_identifier(int index);
  ::fhirbuffs::Identifier* add_identifier();
  ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Identifier >*
      mutable_identifier();
  const ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Identifier >&
      identifier() const;

  // required bool active = 2;
  bool has_active() const;
  void clear_active();
  static const int kActiveFieldNumber = 2;
  bool active() const;
  void set_active(bool value);

  // required .fhirbuffs.CodeableConcept type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::fhirbuffs::CodeableConcept& type() const;
  ::fhirbuffs::CodeableConcept* mutable_type();
  ::fhirbuffs::CodeableConcept* release_type();
  void set_allocated_type(::fhirbuffs::CodeableConcept* type);

  // required string name = 4;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .fhirbuffs.ContactPoint telecom = 5;
  int telecom_size() const;
  void clear_telecom();
  static const int kTelecomFieldNumber = 5;
  const ::fhirbuffs::ContactPoint& telecom(int index) const;
  ::fhirbuffs::ContactPoint* mutable_telecom(int index);
  ::fhirbuffs::ContactPoint* add_telecom();
  ::google::protobuf::RepeatedPtrField< ::fhirbuffs::ContactPoint >*
      mutable_telecom();
  const ::google::protobuf::RepeatedPtrField< ::fhirbuffs::ContactPoint >&
      telecom() const;

  // repeated .fhirbuffs.Address address = 6;
  int address_size() const;
  void clear_address();
  static const int kAddressFieldNumber = 6;
  const ::fhirbuffs::Address& address(int index) const;
  ::fhirbuffs::Address* mutable_address(int index);
  ::fhirbuffs::Address* add_address();
  ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Address >*
      mutable_address();
  const ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Address >&
      address() const;

  // optional .fhirbuffs.Organization partOf = 7;
  bool has_partof() const;
  void clear_partof();
  static const int kPartOfFieldNumber = 7;
  const ::fhirbuffs::Organization& partof() const;
  ::fhirbuffs::Organization* mutable_partof();
  ::fhirbuffs::Organization* release_partof();
  void set_allocated_partof(::fhirbuffs::Organization* partof);

  // repeated .fhirbuffs.Contact contact = 8;
  int contact_size() const;
  void clear_contact();
  static const int kContactFieldNumber = 8;
  const ::fhirbuffs::Contact& contact(int index) const;
  ::fhirbuffs::Contact* mutable_contact(int index);
  ::fhirbuffs::Contact* add_contact();
  ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Contact >*
      mutable_contact();
  const ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Contact >&
      contact() const;

  // @@protoc_insertion_point(class_scope:fhirbuffs.Organization)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_partof();
  inline void clear_has_partof();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Identifier > identifier_;
  ::fhirbuffs::CodeableConcept* type_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::fhirbuffs::ContactPoint > telecom_;
  ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Address > address_;
  ::fhirbuffs::Organization* partof_;
  ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Contact > contact_;
  bool active_;
  friend void  protobuf_AddDesc_primitives_2eproto();
  friend void protobuf_AssignDesc_primitives_2eproto();
  friend void protobuf_ShutdownFile_primitives_2eproto();

  void InitAsDefaultInstance();
  static Organization* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Coding

// required string system = 1;
inline bool Coding::has_system() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Coding::set_has_system() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Coding::clear_has_system() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Coding::clear_system() {
  system_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_system();
}
inline const ::std::string& Coding::system() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Coding.system)
  return system_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Coding::set_system(const ::std::string& value) {
  set_has_system();
  system_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fhirbuffs.Coding.system)
}
inline void Coding::set_system(const char* value) {
  set_has_system();
  system_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fhirbuffs.Coding.system)
}
inline void Coding::set_system(const char* value, size_t size) {
  set_has_system();
  system_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.Coding.system)
}
inline ::std::string* Coding::mutable_system() {
  set_has_system();
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Coding.system)
  return system_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Coding::release_system() {
  clear_has_system();
  return system_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Coding::set_allocated_system(::std::string* system) {
  if (system != NULL) {
    set_has_system();
  } else {
    clear_has_system();
  }
  system_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), system);
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.Coding.system)
}

// required string version = 2;
inline bool Coding::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Coding::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Coding::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Coding::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& Coding::version() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Coding.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Coding::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fhirbuffs.Coding.version)
}
inline void Coding::set_version(const char* value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fhirbuffs.Coding.version)
}
inline void Coding::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.Coding.version)
}
inline ::std::string* Coding::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Coding.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Coding::release_version() {
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Coding::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.Coding.version)
}

// required string code = 3;
inline bool Coding::has_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Coding::set_has_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Coding::clear_has_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Coding::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_code();
}
inline const ::std::string& Coding::code() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Coding.code)
  return code_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Coding::set_code(const ::std::string& value) {
  set_has_code();
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fhirbuffs.Coding.code)
}
inline void Coding::set_code(const char* value) {
  set_has_code();
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fhirbuffs.Coding.code)
}
inline void Coding::set_code(const char* value, size_t size) {
  set_has_code();
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.Coding.code)
}
inline ::std::string* Coding::mutable_code() {
  set_has_code();
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Coding.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Coding::release_code() {
  clear_has_code();
  return code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Coding::set_allocated_code(::std::string* code) {
  if (code != NULL) {
    set_has_code();
  } else {
    clear_has_code();
  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.Coding.code)
}

// required string display = 4;
inline bool Coding::has_display() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Coding::set_has_display() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Coding::clear_has_display() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Coding::clear_display() {
  display_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_display();
}
inline const ::std::string& Coding::display() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Coding.display)
  return display_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Coding::set_display(const ::std::string& value) {
  set_has_display();
  display_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fhirbuffs.Coding.display)
}
inline void Coding::set_display(const char* value) {
  set_has_display();
  display_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fhirbuffs.Coding.display)
}
inline void Coding::set_display(const char* value, size_t size) {
  set_has_display();
  display_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.Coding.display)
}
inline ::std::string* Coding::mutable_display() {
  set_has_display();
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Coding.display)
  return display_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Coding::release_display() {
  clear_has_display();
  return display_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Coding::set_allocated_display(::std::string* display) {
  if (display != NULL) {
    set_has_display();
  } else {
    clear_has_display();
  }
  display_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), display);
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.Coding.display)
}

// required bool userSelected = 5;
inline bool Coding::has_userselected() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Coding::set_has_userselected() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Coding::clear_has_userselected() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Coding::clear_userselected() {
  userselected_ = false;
  clear_has_userselected();
}
inline bool Coding::userselected() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Coding.userSelected)
  return userselected_;
}
inline void Coding::set_userselected(bool value) {
  set_has_userselected();
  userselected_ = value;
  // @@protoc_insertion_point(field_set:fhirbuffs.Coding.userSelected)
}

// -------------------------------------------------------------------

// CodeableConcept

// repeated .fhirbuffs.Coding coding = 1;
inline int CodeableConcept::coding_size() const {
  return coding_.size();
}
inline void CodeableConcept::clear_coding() {
  coding_.Clear();
}
inline const ::fhirbuffs::Coding& CodeableConcept::coding(int index) const {
  // @@protoc_insertion_point(field_get:fhirbuffs.CodeableConcept.coding)
  return coding_.Get(index);
}
inline ::fhirbuffs::Coding* CodeableConcept::mutable_coding(int index) {
  // @@protoc_insertion_point(field_mutable:fhirbuffs.CodeableConcept.coding)
  return coding_.Mutable(index);
}
inline ::fhirbuffs::Coding* CodeableConcept::add_coding() {
  // @@protoc_insertion_point(field_add:fhirbuffs.CodeableConcept.coding)
  return coding_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Coding >*
CodeableConcept::mutable_coding() {
  // @@protoc_insertion_point(field_mutable_list:fhirbuffs.CodeableConcept.coding)
  return &coding_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Coding >&
CodeableConcept::coding() const {
  // @@protoc_insertion_point(field_list:fhirbuffs.CodeableConcept.coding)
  return coding_;
}

// required string text = 2;
inline bool CodeableConcept::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CodeableConcept::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CodeableConcept::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CodeableConcept::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& CodeableConcept::text() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.CodeableConcept.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CodeableConcept::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fhirbuffs.CodeableConcept.text)
}
inline void CodeableConcept::set_text(const char* value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fhirbuffs.CodeableConcept.text)
}
inline void CodeableConcept::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.CodeableConcept.text)
}
inline ::std::string* CodeableConcept::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:fhirbuffs.CodeableConcept.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CodeableConcept::release_text() {
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CodeableConcept::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.CodeableConcept.text)
}

// -------------------------------------------------------------------

// Period

// required int64 start = 1;
inline bool Period::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Period::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Period::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Period::clear_start() {
  start_ = GOOGLE_LONGLONG(0);
  clear_has_start();
}
inline ::google::protobuf::int64 Period::start() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Period.start)
  return start_;
}
inline void Period::set_start(::google::protobuf::int64 value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:fhirbuffs.Period.start)
}

// required int64 end = 2;
inline bool Period::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Period::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Period::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Period::clear_end() {
  end_ = GOOGLE_LONGLONG(0);
  clear_has_end();
}
inline ::google::protobuf::int64 Period::end() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Period.end)
  return end_;
}
inline void Period::set_end(::google::protobuf::int64 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:fhirbuffs.Period.end)
}

// -------------------------------------------------------------------

// Address

// required .fhirbuffs.Address.AddressUses use = 1;
inline bool Address::has_use() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Address::set_has_use() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Address::clear_has_use() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Address::clear_use() {
  use_ = 0;
  clear_has_use();
}
inline ::fhirbuffs::Address_AddressUses Address::use() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Address.use)
  return static_cast< ::fhirbuffs::Address_AddressUses >(use_);
}
inline void Address::set_use(::fhirbuffs::Address_AddressUses value) {
  assert(::fhirbuffs::Address_AddressUses_IsValid(value));
  set_has_use();
  use_ = value;
  // @@protoc_insertion_point(field_set:fhirbuffs.Address.use)
}

// required .fhirbuffs.Address.AddressTypes type = 2;
inline bool Address::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Address::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Address::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Address::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::fhirbuffs::Address_AddressTypes Address::type() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Address.type)
  return static_cast< ::fhirbuffs::Address_AddressTypes >(type_);
}
inline void Address::set_type(::fhirbuffs::Address_AddressTypes value) {
  assert(::fhirbuffs::Address_AddressTypes_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:fhirbuffs.Address.type)
}

// required string text = 3;
inline bool Address::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Address::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Address::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Address::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& Address::text() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Address.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Address::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fhirbuffs.Address.text)
}
inline void Address::set_text(const char* value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fhirbuffs.Address.text)
}
inline void Address::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.Address.text)
}
inline ::std::string* Address::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Address.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Address::release_text() {
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Address::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.Address.text)
}

// repeated string line = 4;
inline int Address::line_size() const {
  return line_.size();
}
inline void Address::clear_line() {
  line_.Clear();
}
inline const ::std::string& Address::line(int index) const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Address.line)
  return line_.Get(index);
}
inline ::std::string* Address::mutable_line(int index) {
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Address.line)
  return line_.Mutable(index);
}
inline void Address::set_line(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:fhirbuffs.Address.line)
  line_.Mutable(index)->assign(value);
}
inline void Address::set_line(int index, const char* value) {
  line_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fhirbuffs.Address.line)
}
inline void Address::set_line(int index, const char* value, size_t size) {
  line_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.Address.line)
}
inline ::std::string* Address::add_line() {
  return line_.Add();
}
inline void Address::add_line(const ::std::string& value) {
  line_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fhirbuffs.Address.line)
}
inline void Address::add_line(const char* value) {
  line_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fhirbuffs.Address.line)
}
inline void Address::add_line(const char* value, size_t size) {
  line_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fhirbuffs.Address.line)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Address::line() const {
  // @@protoc_insertion_point(field_list:fhirbuffs.Address.line)
  return line_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Address::mutable_line() {
  // @@protoc_insertion_point(field_mutable_list:fhirbuffs.Address.line)
  return &line_;
}

// required string city = 5;
inline bool Address::has_city() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Address::set_has_city() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Address::clear_has_city() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Address::clear_city() {
  city_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_city();
}
inline const ::std::string& Address::city() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Address.city)
  return city_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Address::set_city(const ::std::string& value) {
  set_has_city();
  city_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fhirbuffs.Address.city)
}
inline void Address::set_city(const char* value) {
  set_has_city();
  city_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fhirbuffs.Address.city)
}
inline void Address::set_city(const char* value, size_t size) {
  set_has_city();
  city_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.Address.city)
}
inline ::std::string* Address::mutable_city() {
  set_has_city();
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Address.city)
  return city_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Address::release_city() {
  clear_has_city();
  return city_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Address::set_allocated_city(::std::string* city) {
  if (city != NULL) {
    set_has_city();
  } else {
    clear_has_city();
  }
  city_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), city);
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.Address.city)
}

// required string district = 6;
inline bool Address::has_district() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Address::set_has_district() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Address::clear_has_district() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Address::clear_district() {
  district_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_district();
}
inline const ::std::string& Address::district() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Address.district)
  return district_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Address::set_district(const ::std::string& value) {
  set_has_district();
  district_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fhirbuffs.Address.district)
}
inline void Address::set_district(const char* value) {
  set_has_district();
  district_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fhirbuffs.Address.district)
}
inline void Address::set_district(const char* value, size_t size) {
  set_has_district();
  district_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.Address.district)
}
inline ::std::string* Address::mutable_district() {
  set_has_district();
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Address.district)
  return district_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Address::release_district() {
  clear_has_district();
  return district_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Address::set_allocated_district(::std::string* district) {
  if (district != NULL) {
    set_has_district();
  } else {
    clear_has_district();
  }
  district_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), district);
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.Address.district)
}

// required string state = 7;
inline bool Address::has_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Address::set_has_state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Address::clear_has_state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Address::clear_state() {
  state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_state();
}
inline const ::std::string& Address::state() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Address.state)
  return state_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Address::set_state(const ::std::string& value) {
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fhirbuffs.Address.state)
}
inline void Address::set_state(const char* value) {
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fhirbuffs.Address.state)
}
inline void Address::set_state(const char* value, size_t size) {
  set_has_state();
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.Address.state)
}
inline ::std::string* Address::mutable_state() {
  set_has_state();
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Address.state)
  return state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Address::release_state() {
  clear_has_state();
  return state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Address::set_allocated_state(::std::string* state) {
  if (state != NULL) {
    set_has_state();
  } else {
    clear_has_state();
  }
  state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.Address.state)
}

// required string postalCode = 8;
inline bool Address::has_postalcode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Address::set_has_postalcode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Address::clear_has_postalcode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Address::clear_postalcode() {
  postalcode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_postalcode();
}
inline const ::std::string& Address::postalcode() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Address.postalCode)
  return postalcode_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Address::set_postalcode(const ::std::string& value) {
  set_has_postalcode();
  postalcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fhirbuffs.Address.postalCode)
}
inline void Address::set_postalcode(const char* value) {
  set_has_postalcode();
  postalcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fhirbuffs.Address.postalCode)
}
inline void Address::set_postalcode(const char* value, size_t size) {
  set_has_postalcode();
  postalcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.Address.postalCode)
}
inline ::std::string* Address::mutable_postalcode() {
  set_has_postalcode();
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Address.postalCode)
  return postalcode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Address::release_postalcode() {
  clear_has_postalcode();
  return postalcode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Address::set_allocated_postalcode(::std::string* postalcode) {
  if (postalcode != NULL) {
    set_has_postalcode();
  } else {
    clear_has_postalcode();
  }
  postalcode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), postalcode);
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.Address.postalCode)
}

// required string country = 9;
inline bool Address::has_country() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Address::set_has_country() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Address::clear_has_country() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Address::clear_country() {
  country_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_country();
}
inline const ::std::string& Address::country() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Address.country)
  return country_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Address::set_country(const ::std::string& value) {
  set_has_country();
  country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fhirbuffs.Address.country)
}
inline void Address::set_country(const char* value) {
  set_has_country();
  country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fhirbuffs.Address.country)
}
inline void Address::set_country(const char* value, size_t size) {
  set_has_country();
  country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.Address.country)
}
inline ::std::string* Address::mutable_country() {
  set_has_country();
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Address.country)
  return country_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Address::release_country() {
  clear_has_country();
  return country_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Address::set_allocated_country(::std::string* country) {
  if (country != NULL) {
    set_has_country();
  } else {
    clear_has_country();
  }
  country_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), country);
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.Address.country)
}

// required .fhirbuffs.Period period = 10;
inline bool Address::has_period() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Address::set_has_period() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Address::clear_has_period() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Address::clear_period() {
  if (period_ != NULL) period_->::fhirbuffs::Period::Clear();
  clear_has_period();
}
inline const ::fhirbuffs::Period& Address::period() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Address.period)
  return period_ != NULL ? *period_ : *default_instance_->period_;
}
inline ::fhirbuffs::Period* Address::mutable_period() {
  set_has_period();
  if (period_ == NULL) {
    period_ = new ::fhirbuffs::Period;
  }
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Address.period)
  return period_;
}
inline ::fhirbuffs::Period* Address::release_period() {
  clear_has_period();
  ::fhirbuffs::Period* temp = period_;
  period_ = NULL;
  return temp;
}
inline void Address::set_allocated_period(::fhirbuffs::Period* period) {
  delete period_;
  period_ = period;
  if (period) {
    set_has_period();
  } else {
    clear_has_period();
  }
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.Address.period)
}

// -------------------------------------------------------------------

// HumanName

// required .fhirbuffs.HumanName.HumanNameUses use = 1;
inline bool HumanName::has_use() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HumanName::set_has_use() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HumanName::clear_has_use() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HumanName::clear_use() {
  use_ = 0;
  clear_has_use();
}
inline ::fhirbuffs::HumanName_HumanNameUses HumanName::use() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.HumanName.use)
  return static_cast< ::fhirbuffs::HumanName_HumanNameUses >(use_);
}
inline void HumanName::set_use(::fhirbuffs::HumanName_HumanNameUses value) {
  assert(::fhirbuffs::HumanName_HumanNameUses_IsValid(value));
  set_has_use();
  use_ = value;
  // @@protoc_insertion_point(field_set:fhirbuffs.HumanName.use)
}

// required string text = 2;
inline bool HumanName::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HumanName::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HumanName::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HumanName::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& HumanName::text() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.HumanName.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HumanName::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fhirbuffs.HumanName.text)
}
inline void HumanName::set_text(const char* value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fhirbuffs.HumanName.text)
}
inline void HumanName::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.HumanName.text)
}
inline ::std::string* HumanName::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:fhirbuffs.HumanName.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HumanName::release_text() {
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HumanName::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.HumanName.text)
}

// repeated string family = 3;
inline int HumanName::family_size() const {
  return family_.size();
}
inline void HumanName::clear_family() {
  family_.Clear();
}
inline const ::std::string& HumanName::family(int index) const {
  // @@protoc_insertion_point(field_get:fhirbuffs.HumanName.family)
  return family_.Get(index);
}
inline ::std::string* HumanName::mutable_family(int index) {
  // @@protoc_insertion_point(field_mutable:fhirbuffs.HumanName.family)
  return family_.Mutable(index);
}
inline void HumanName::set_family(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:fhirbuffs.HumanName.family)
  family_.Mutable(index)->assign(value);
}
inline void HumanName::set_family(int index, const char* value) {
  family_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fhirbuffs.HumanName.family)
}
inline void HumanName::set_family(int index, const char* value, size_t size) {
  family_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.HumanName.family)
}
inline ::std::string* HumanName::add_family() {
  return family_.Add();
}
inline void HumanName::add_family(const ::std::string& value) {
  family_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fhirbuffs.HumanName.family)
}
inline void HumanName::add_family(const char* value) {
  family_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fhirbuffs.HumanName.family)
}
inline void HumanName::add_family(const char* value, size_t size) {
  family_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fhirbuffs.HumanName.family)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HumanName::family() const {
  // @@protoc_insertion_point(field_list:fhirbuffs.HumanName.family)
  return family_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HumanName::mutable_family() {
  // @@protoc_insertion_point(field_mutable_list:fhirbuffs.HumanName.family)
  return &family_;
}

// repeated string given = 4;
inline int HumanName::given_size() const {
  return given_.size();
}
inline void HumanName::clear_given() {
  given_.Clear();
}
inline const ::std::string& HumanName::given(int index) const {
  // @@protoc_insertion_point(field_get:fhirbuffs.HumanName.given)
  return given_.Get(index);
}
inline ::std::string* HumanName::mutable_given(int index) {
  // @@protoc_insertion_point(field_mutable:fhirbuffs.HumanName.given)
  return given_.Mutable(index);
}
inline void HumanName::set_given(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:fhirbuffs.HumanName.given)
  given_.Mutable(index)->assign(value);
}
inline void HumanName::set_given(int index, const char* value) {
  given_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fhirbuffs.HumanName.given)
}
inline void HumanName::set_given(int index, const char* value, size_t size) {
  given_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.HumanName.given)
}
inline ::std::string* HumanName::add_given() {
  return given_.Add();
}
inline void HumanName::add_given(const ::std::string& value) {
  given_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fhirbuffs.HumanName.given)
}
inline void HumanName::add_given(const char* value) {
  given_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fhirbuffs.HumanName.given)
}
inline void HumanName::add_given(const char* value, size_t size) {
  given_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fhirbuffs.HumanName.given)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HumanName::given() const {
  // @@protoc_insertion_point(field_list:fhirbuffs.HumanName.given)
  return given_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HumanName::mutable_given() {
  // @@protoc_insertion_point(field_mutable_list:fhirbuffs.HumanName.given)
  return &given_;
}

// repeated string prefix = 5;
inline int HumanName::prefix_size() const {
  return prefix_.size();
}
inline void HumanName::clear_prefix() {
  prefix_.Clear();
}
inline const ::std::string& HumanName::prefix(int index) const {
  // @@protoc_insertion_point(field_get:fhirbuffs.HumanName.prefix)
  return prefix_.Get(index);
}
inline ::std::string* HumanName::mutable_prefix(int index) {
  // @@protoc_insertion_point(field_mutable:fhirbuffs.HumanName.prefix)
  return prefix_.Mutable(index);
}
inline void HumanName::set_prefix(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:fhirbuffs.HumanName.prefix)
  prefix_.Mutable(index)->assign(value);
}
inline void HumanName::set_prefix(int index, const char* value) {
  prefix_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fhirbuffs.HumanName.prefix)
}
inline void HumanName::set_prefix(int index, const char* value, size_t size) {
  prefix_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.HumanName.prefix)
}
inline ::std::string* HumanName::add_prefix() {
  return prefix_.Add();
}
inline void HumanName::add_prefix(const ::std::string& value) {
  prefix_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fhirbuffs.HumanName.prefix)
}
inline void HumanName::add_prefix(const char* value) {
  prefix_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fhirbuffs.HumanName.prefix)
}
inline void HumanName::add_prefix(const char* value, size_t size) {
  prefix_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fhirbuffs.HumanName.prefix)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HumanName::prefix() const {
  // @@protoc_insertion_point(field_list:fhirbuffs.HumanName.prefix)
  return prefix_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HumanName::mutable_prefix() {
  // @@protoc_insertion_point(field_mutable_list:fhirbuffs.HumanName.prefix)
  return &prefix_;
}

// repeated string suffix = 6;
inline int HumanName::suffix_size() const {
  return suffix_.size();
}
inline void HumanName::clear_suffix() {
  suffix_.Clear();
}
inline const ::std::string& HumanName::suffix(int index) const {
  // @@protoc_insertion_point(field_get:fhirbuffs.HumanName.suffix)
  return suffix_.Get(index);
}
inline ::std::string* HumanName::mutable_suffix(int index) {
  // @@protoc_insertion_point(field_mutable:fhirbuffs.HumanName.suffix)
  return suffix_.Mutable(index);
}
inline void HumanName::set_suffix(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:fhirbuffs.HumanName.suffix)
  suffix_.Mutable(index)->assign(value);
}
inline void HumanName::set_suffix(int index, const char* value) {
  suffix_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fhirbuffs.HumanName.suffix)
}
inline void HumanName::set_suffix(int index, const char* value, size_t size) {
  suffix_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.HumanName.suffix)
}
inline ::std::string* HumanName::add_suffix() {
  return suffix_.Add();
}
inline void HumanName::add_suffix(const ::std::string& value) {
  suffix_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fhirbuffs.HumanName.suffix)
}
inline void HumanName::add_suffix(const char* value) {
  suffix_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fhirbuffs.HumanName.suffix)
}
inline void HumanName::add_suffix(const char* value, size_t size) {
  suffix_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fhirbuffs.HumanName.suffix)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HumanName::suffix() const {
  // @@protoc_insertion_point(field_list:fhirbuffs.HumanName.suffix)
  return suffix_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HumanName::mutable_suffix() {
  // @@protoc_insertion_point(field_mutable_list:fhirbuffs.HumanName.suffix)
  return &suffix_;
}

// required .fhirbuffs.Period period = 7;
inline bool HumanName::has_period() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HumanName::set_has_period() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HumanName::clear_has_period() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HumanName::clear_period() {
  if (period_ != NULL) period_->::fhirbuffs::Period::Clear();
  clear_has_period();
}
inline const ::fhirbuffs::Period& HumanName::period() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.HumanName.period)
  return period_ != NULL ? *period_ : *default_instance_->period_;
}
inline ::fhirbuffs::Period* HumanName::mutable_period() {
  set_has_period();
  if (period_ == NULL) {
    period_ = new ::fhirbuffs::Period;
  }
  // @@protoc_insertion_point(field_mutable:fhirbuffs.HumanName.period)
  return period_;
}
inline ::fhirbuffs::Period* HumanName::release_period() {
  clear_has_period();
  ::fhirbuffs::Period* temp = period_;
  period_ = NULL;
  return temp;
}
inline void HumanName::set_allocated_period(::fhirbuffs::Period* period) {
  delete period_;
  period_ = period;
  if (period) {
    set_has_period();
  } else {
    clear_has_period();
  }
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.HumanName.period)
}

// -------------------------------------------------------------------

// ContactPoint

// optional .fhirbuffs.ContactPoint.AuthorReferences authorReference = 1;
inline bool ContactPoint::has_authorreference() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactPoint::set_has_authorreference() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactPoint::clear_has_authorreference() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactPoint::clear_authorreference() {
  authorreference_ = 0;
  clear_has_authorreference();
}
inline ::fhirbuffs::ContactPoint_AuthorReferences ContactPoint::authorreference() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.ContactPoint.authorReference)
  return static_cast< ::fhirbuffs::ContactPoint_AuthorReferences >(authorreference_);
}
inline void ContactPoint::set_authorreference(::fhirbuffs::ContactPoint_AuthorReferences value) {
  assert(::fhirbuffs::ContactPoint_AuthorReferences_IsValid(value));
  set_has_authorreference();
  authorreference_ = value;
  // @@protoc_insertion_point(field_set:fhirbuffs.ContactPoint.authorReference)
}

// required string authorString = 2;
inline bool ContactPoint::has_authorstring() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContactPoint::set_has_authorstring() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContactPoint::clear_has_authorstring() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContactPoint::clear_authorstring() {
  authorstring_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_authorstring();
}
inline const ::std::string& ContactPoint::authorstring() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.ContactPoint.authorString)
  return authorstring_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContactPoint::set_authorstring(const ::std::string& value) {
  set_has_authorstring();
  authorstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fhirbuffs.ContactPoint.authorString)
}
inline void ContactPoint::set_authorstring(const char* value) {
  set_has_authorstring();
  authorstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fhirbuffs.ContactPoint.authorString)
}
inline void ContactPoint::set_authorstring(const char* value, size_t size) {
  set_has_authorstring();
  authorstring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.ContactPoint.authorString)
}
inline ::std::string* ContactPoint::mutable_authorstring() {
  set_has_authorstring();
  // @@protoc_insertion_point(field_mutable:fhirbuffs.ContactPoint.authorString)
  return authorstring_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContactPoint::release_authorstring() {
  clear_has_authorstring();
  return authorstring_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContactPoint::set_allocated_authorstring(::std::string* authorstring) {
  if (authorstring != NULL) {
    set_has_authorstring();
  } else {
    clear_has_authorstring();
  }
  authorstring_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), authorstring);
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.ContactPoint.authorString)
}

// optional int64 time = 3;
inline bool ContactPoint::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContactPoint::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContactPoint::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContactPoint::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 ContactPoint::time() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.ContactPoint.time)
  return time_;
}
inline void ContactPoint::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:fhirbuffs.ContactPoint.time)
}

// required string text = 4;
inline bool ContactPoint::has_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContactPoint::set_has_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContactPoint::clear_has_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContactPoint::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& ContactPoint::text() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.ContactPoint.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContactPoint::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fhirbuffs.ContactPoint.text)
}
inline void ContactPoint::set_text(const char* value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fhirbuffs.ContactPoint.text)
}
inline void ContactPoint::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.ContactPoint.text)
}
inline ::std::string* ContactPoint::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:fhirbuffs.ContactPoint.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContactPoint::release_text() {
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContactPoint::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.ContactPoint.text)
}

// -------------------------------------------------------------------

// Contact

// required .fhirbuffs.CodeableConcept purpose = 1;
inline bool Contact::has_purpose() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Contact::set_has_purpose() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Contact::clear_has_purpose() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Contact::clear_purpose() {
  if (purpose_ != NULL) purpose_->::fhirbuffs::CodeableConcept::Clear();
  clear_has_purpose();
}
inline const ::fhirbuffs::CodeableConcept& Contact::purpose() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Contact.purpose)
  return purpose_ != NULL ? *purpose_ : *default_instance_->purpose_;
}
inline ::fhirbuffs::CodeableConcept* Contact::mutable_purpose() {
  set_has_purpose();
  if (purpose_ == NULL) {
    purpose_ = new ::fhirbuffs::CodeableConcept;
  }
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Contact.purpose)
  return purpose_;
}
inline ::fhirbuffs::CodeableConcept* Contact::release_purpose() {
  clear_has_purpose();
  ::fhirbuffs::CodeableConcept* temp = purpose_;
  purpose_ = NULL;
  return temp;
}
inline void Contact::set_allocated_purpose(::fhirbuffs::CodeableConcept* purpose) {
  delete purpose_;
  purpose_ = purpose;
  if (purpose) {
    set_has_purpose();
  } else {
    clear_has_purpose();
  }
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.Contact.purpose)
}

// required .fhirbuffs.HumanName name = 2;
inline bool Contact::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Contact::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Contact::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Contact::clear_name() {
  if (name_ != NULL) name_->::fhirbuffs::HumanName::Clear();
  clear_has_name();
}
inline const ::fhirbuffs::HumanName& Contact::name() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Contact.name)
  return name_ != NULL ? *name_ : *default_instance_->name_;
}
inline ::fhirbuffs::HumanName* Contact::mutable_name() {
  set_has_name();
  if (name_ == NULL) {
    name_ = new ::fhirbuffs::HumanName;
  }
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Contact.name)
  return name_;
}
inline ::fhirbuffs::HumanName* Contact::release_name() {
  clear_has_name();
  ::fhirbuffs::HumanName* temp = name_;
  name_ = NULL;
  return temp;
}
inline void Contact::set_allocated_name(::fhirbuffs::HumanName* name) {
  delete name_;
  name_ = name;
  if (name) {
    set_has_name();
  } else {
    clear_has_name();
  }
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.Contact.name)
}

// repeated .fhirbuffs.ContactPoint telecom = 3;
inline int Contact::telecom_size() const {
  return telecom_.size();
}
inline void Contact::clear_telecom() {
  telecom_.Clear();
}
inline const ::fhirbuffs::ContactPoint& Contact::telecom(int index) const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Contact.telecom)
  return telecom_.Get(index);
}
inline ::fhirbuffs::ContactPoint* Contact::mutable_telecom(int index) {
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Contact.telecom)
  return telecom_.Mutable(index);
}
inline ::fhirbuffs::ContactPoint* Contact::add_telecom() {
  // @@protoc_insertion_point(field_add:fhirbuffs.Contact.telecom)
  return telecom_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fhirbuffs::ContactPoint >*
Contact::mutable_telecom() {
  // @@protoc_insertion_point(field_mutable_list:fhirbuffs.Contact.telecom)
  return &telecom_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fhirbuffs::ContactPoint >&
Contact::telecom() const {
  // @@protoc_insertion_point(field_list:fhirbuffs.Contact.telecom)
  return telecom_;
}

// required .fhirbuffs.Address address = 4;
inline bool Contact::has_address() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Contact::set_has_address() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Contact::clear_has_address() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Contact::clear_address() {
  if (address_ != NULL) address_->::fhirbuffs::Address::Clear();
  clear_has_address();
}
inline const ::fhirbuffs::Address& Contact::address() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Contact.address)
  return address_ != NULL ? *address_ : *default_instance_->address_;
}
inline ::fhirbuffs::Address* Contact::mutable_address() {
  set_has_address();
  if (address_ == NULL) {
    address_ = new ::fhirbuffs::Address;
  }
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Contact.address)
  return address_;
}
inline ::fhirbuffs::Address* Contact::release_address() {
  clear_has_address();
  ::fhirbuffs::Address* temp = address_;
  address_ = NULL;
  return temp;
}
inline void Contact::set_allocated_address(::fhirbuffs::Address* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.Contact.address)
}

// -------------------------------------------------------------------

// Identifier

// required .fhirbuffs.Identifier.IdentifierUses use = 1;
inline bool Identifier::has_use() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Identifier::set_has_use() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Identifier::clear_has_use() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Identifier::clear_use() {
  use_ = 0;
  clear_has_use();
}
inline ::fhirbuffs::Identifier_IdentifierUses Identifier::use() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Identifier.use)
  return static_cast< ::fhirbuffs::Identifier_IdentifierUses >(use_);
}
inline void Identifier::set_use(::fhirbuffs::Identifier_IdentifierUses value) {
  assert(::fhirbuffs::Identifier_IdentifierUses_IsValid(value));
  set_has_use();
  use_ = value;
  // @@protoc_insertion_point(field_set:fhirbuffs.Identifier.use)
}

// repeated .fhirbuffs.CodeableConcept type = 2;
inline int Identifier::type_size() const {
  return type_.size();
}
inline void Identifier::clear_type() {
  type_.Clear();
}
inline const ::fhirbuffs::CodeableConcept& Identifier::type(int index) const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Identifier.type)
  return type_.Get(index);
}
inline ::fhirbuffs::CodeableConcept* Identifier::mutable_type(int index) {
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Identifier.type)
  return type_.Mutable(index);
}
inline ::fhirbuffs::CodeableConcept* Identifier::add_type() {
  // @@protoc_insertion_point(field_add:fhirbuffs.Identifier.type)
  return type_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fhirbuffs::CodeableConcept >*
Identifier::mutable_type() {
  // @@protoc_insertion_point(field_mutable_list:fhirbuffs.Identifier.type)
  return &type_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fhirbuffs::CodeableConcept >&
Identifier::type() const {
  // @@protoc_insertion_point(field_list:fhirbuffs.Identifier.type)
  return type_;
}

// required string system = 3;
inline bool Identifier::has_system() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Identifier::set_has_system() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Identifier::clear_has_system() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Identifier::clear_system() {
  system_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_system();
}
inline const ::std::string& Identifier::system() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Identifier.system)
  return system_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_system(const ::std::string& value) {
  set_has_system();
  system_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fhirbuffs.Identifier.system)
}
inline void Identifier::set_system(const char* value) {
  set_has_system();
  system_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fhirbuffs.Identifier.system)
}
inline void Identifier::set_system(const char* value, size_t size) {
  set_has_system();
  system_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.Identifier.system)
}
inline ::std::string* Identifier::mutable_system() {
  set_has_system();
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Identifier.system)
  return system_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Identifier::release_system() {
  clear_has_system();
  return system_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_allocated_system(::std::string* system) {
  if (system != NULL) {
    set_has_system();
  } else {
    clear_has_system();
  }
  system_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), system);
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.Identifier.system)
}

// required string value = 4;
inline bool Identifier::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Identifier::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Identifier::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Identifier::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& Identifier::value() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Identifier.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fhirbuffs.Identifier.value)
}
inline void Identifier::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fhirbuffs.Identifier.value)
}
inline void Identifier::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.Identifier.value)
}
inline ::std::string* Identifier::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Identifier.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Identifier::release_value() {
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.Identifier.value)
}

// required .fhirbuffs.Period period = 5;
inline bool Identifier::has_period() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Identifier::set_has_period() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Identifier::clear_has_period() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Identifier::clear_period() {
  if (period_ != NULL) period_->::fhirbuffs::Period::Clear();
  clear_has_period();
}
inline const ::fhirbuffs::Period& Identifier::period() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Identifier.period)
  return period_ != NULL ? *period_ : *default_instance_->period_;
}
inline ::fhirbuffs::Period* Identifier::mutable_period() {
  set_has_period();
  if (period_ == NULL) {
    period_ = new ::fhirbuffs::Period;
  }
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Identifier.period)
  return period_;
}
inline ::fhirbuffs::Period* Identifier::release_period() {
  clear_has_period();
  ::fhirbuffs::Period* temp = period_;
  period_ = NULL;
  return temp;
}
inline void Identifier::set_allocated_period(::fhirbuffs::Period* period) {
  delete period_;
  period_ = period;
  if (period) {
    set_has_period();
  } else {
    clear_has_period();
  }
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.Identifier.period)
}

// repeated .fhirbuffs.Organization assigner = 6;
inline int Identifier::assigner_size() const {
  return assigner_.size();
}
inline void Identifier::clear_assigner() {
  assigner_.Clear();
}
inline const ::fhirbuffs::Organization& Identifier::assigner(int index) const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Identifier.assigner)
  return assigner_.Get(index);
}
inline ::fhirbuffs::Organization* Identifier::mutable_assigner(int index) {
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Identifier.assigner)
  return assigner_.Mutable(index);
}
inline ::fhirbuffs::Organization* Identifier::add_assigner() {
  // @@protoc_insertion_point(field_add:fhirbuffs.Identifier.assigner)
  return assigner_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Organization >*
Identifier::mutable_assigner() {
  // @@protoc_insertion_point(field_mutable_list:fhirbuffs.Identifier.assigner)
  return &assigner_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Organization >&
Identifier::assigner() const {
  // @@protoc_insertion_point(field_list:fhirbuffs.Identifier.assigner)
  return assigner_;
}

// -------------------------------------------------------------------

// Organization

// repeated .fhirbuffs.Identifier identifier = 1;
inline int Organization::identifier_size() const {
  return identifier_.size();
}
inline void Organization::clear_identifier() {
  identifier_.Clear();
}
inline const ::fhirbuffs::Identifier& Organization::identifier(int index) const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Organization.identifier)
  return identifier_.Get(index);
}
inline ::fhirbuffs::Identifier* Organization::mutable_identifier(int index) {
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Organization.identifier)
  return identifier_.Mutable(index);
}
inline ::fhirbuffs::Identifier* Organization::add_identifier() {
  // @@protoc_insertion_point(field_add:fhirbuffs.Organization.identifier)
  return identifier_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Identifier >*
Organization::mutable_identifier() {
  // @@protoc_insertion_point(field_mutable_list:fhirbuffs.Organization.identifier)
  return &identifier_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Identifier >&
Organization::identifier() const {
  // @@protoc_insertion_point(field_list:fhirbuffs.Organization.identifier)
  return identifier_;
}

// required bool active = 2;
inline bool Organization::has_active() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Organization::set_has_active() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Organization::clear_has_active() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Organization::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool Organization::active() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Organization.active)
  return active_;
}
inline void Organization::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:fhirbuffs.Organization.active)
}

// required .fhirbuffs.CodeableConcept type = 3;
inline bool Organization::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Organization::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Organization::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Organization::clear_type() {
  if (type_ != NULL) type_->::fhirbuffs::CodeableConcept::Clear();
  clear_has_type();
}
inline const ::fhirbuffs::CodeableConcept& Organization::type() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Organization.type)
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::fhirbuffs::CodeableConcept* Organization::mutable_type() {
  set_has_type();
  if (type_ == NULL) {
    type_ = new ::fhirbuffs::CodeableConcept;
  }
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Organization.type)
  return type_;
}
inline ::fhirbuffs::CodeableConcept* Organization::release_type() {
  clear_has_type();
  ::fhirbuffs::CodeableConcept* temp = type_;
  type_ = NULL;
  return temp;
}
inline void Organization::set_allocated_type(::fhirbuffs::CodeableConcept* type) {
  delete type_;
  type_ = type;
  if (type) {
    set_has_type();
  } else {
    clear_has_type();
  }
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.Organization.type)
}

// required string name = 4;
inline bool Organization::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Organization::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Organization::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Organization::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Organization::name() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Organization.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Organization::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fhirbuffs.Organization.name)
}
inline void Organization::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fhirbuffs.Organization.name)
}
inline void Organization::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fhirbuffs.Organization.name)
}
inline ::std::string* Organization::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Organization.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Organization::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Organization::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.Organization.name)
}

// repeated .fhirbuffs.ContactPoint telecom = 5;
inline int Organization::telecom_size() const {
  return telecom_.size();
}
inline void Organization::clear_telecom() {
  telecom_.Clear();
}
inline const ::fhirbuffs::ContactPoint& Organization::telecom(int index) const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Organization.telecom)
  return telecom_.Get(index);
}
inline ::fhirbuffs::ContactPoint* Organization::mutable_telecom(int index) {
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Organization.telecom)
  return telecom_.Mutable(index);
}
inline ::fhirbuffs::ContactPoint* Organization::add_telecom() {
  // @@protoc_insertion_point(field_add:fhirbuffs.Organization.telecom)
  return telecom_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fhirbuffs::ContactPoint >*
Organization::mutable_telecom() {
  // @@protoc_insertion_point(field_mutable_list:fhirbuffs.Organization.telecom)
  return &telecom_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fhirbuffs::ContactPoint >&
Organization::telecom() const {
  // @@protoc_insertion_point(field_list:fhirbuffs.Organization.telecom)
  return telecom_;
}

// repeated .fhirbuffs.Address address = 6;
inline int Organization::address_size() const {
  return address_.size();
}
inline void Organization::clear_address() {
  address_.Clear();
}
inline const ::fhirbuffs::Address& Organization::address(int index) const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Organization.address)
  return address_.Get(index);
}
inline ::fhirbuffs::Address* Organization::mutable_address(int index) {
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Organization.address)
  return address_.Mutable(index);
}
inline ::fhirbuffs::Address* Organization::add_address() {
  // @@protoc_insertion_point(field_add:fhirbuffs.Organization.address)
  return address_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Address >*
Organization::mutable_address() {
  // @@protoc_insertion_point(field_mutable_list:fhirbuffs.Organization.address)
  return &address_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Address >&
Organization::address() const {
  // @@protoc_insertion_point(field_list:fhirbuffs.Organization.address)
  return address_;
}

// optional .fhirbuffs.Organization partOf = 7;
inline bool Organization::has_partof() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Organization::set_has_partof() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Organization::clear_has_partof() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Organization::clear_partof() {
  if (partof_ != NULL) partof_->::fhirbuffs::Organization::Clear();
  clear_has_partof();
}
inline const ::fhirbuffs::Organization& Organization::partof() const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Organization.partOf)
  return partof_ != NULL ? *partof_ : *default_instance_->partof_;
}
inline ::fhirbuffs::Organization* Organization::mutable_partof() {
  set_has_partof();
  if (partof_ == NULL) {
    partof_ = new ::fhirbuffs::Organization;
  }
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Organization.partOf)
  return partof_;
}
inline ::fhirbuffs::Organization* Organization::release_partof() {
  clear_has_partof();
  ::fhirbuffs::Organization* temp = partof_;
  partof_ = NULL;
  return temp;
}
inline void Organization::set_allocated_partof(::fhirbuffs::Organization* partof) {
  delete partof_;
  partof_ = partof;
  if (partof) {
    set_has_partof();
  } else {
    clear_has_partof();
  }
  // @@protoc_insertion_point(field_set_allocated:fhirbuffs.Organization.partOf)
}

// repeated .fhirbuffs.Contact contact = 8;
inline int Organization::contact_size() const {
  return contact_.size();
}
inline void Organization::clear_contact() {
  contact_.Clear();
}
inline const ::fhirbuffs::Contact& Organization::contact(int index) const {
  // @@protoc_insertion_point(field_get:fhirbuffs.Organization.contact)
  return contact_.Get(index);
}
inline ::fhirbuffs::Contact* Organization::mutable_contact(int index) {
  // @@protoc_insertion_point(field_mutable:fhirbuffs.Organization.contact)
  return contact_.Mutable(index);
}
inline ::fhirbuffs::Contact* Organization::add_contact() {
  // @@protoc_insertion_point(field_add:fhirbuffs.Organization.contact)
  return contact_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Contact >*
Organization::mutable_contact() {
  // @@protoc_insertion_point(field_mutable_list:fhirbuffs.Organization.contact)
  return &contact_;
}
inline const ::google::protobuf::RepeatedPtrField< ::fhirbuffs::Contact >&
Organization::contact() const {
  // @@protoc_insertion_point(field_list:fhirbuffs.Organization.contact)
  return contact_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace fhirbuffs

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::fhirbuffs::Address_AddressUses> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fhirbuffs::Address_AddressUses>() {
  return ::fhirbuffs::Address_AddressUses_descriptor();
}
template <> struct is_proto_enum< ::fhirbuffs::Address_AddressTypes> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fhirbuffs::Address_AddressTypes>() {
  return ::fhirbuffs::Address_AddressTypes_descriptor();
}
template <> struct is_proto_enum< ::fhirbuffs::HumanName_HumanNameUses> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fhirbuffs::HumanName_HumanNameUses>() {
  return ::fhirbuffs::HumanName_HumanNameUses_descriptor();
}
template <> struct is_proto_enum< ::fhirbuffs::ContactPoint_AuthorReferences> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fhirbuffs::ContactPoint_AuthorReferences>() {
  return ::fhirbuffs::ContactPoint_AuthorReferences_descriptor();
}
template <> struct is_proto_enum< ::fhirbuffs::Identifier_IdentifierUses> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fhirbuffs::Identifier_IdentifierUses>() {
  return ::fhirbuffs::Identifier_IdentifierUses_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_primitives_2eproto__INCLUDED
