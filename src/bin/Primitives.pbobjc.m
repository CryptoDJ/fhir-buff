// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: primitives.proto

#import "GPBProtocolBuffers_RuntimeSupport.h"
#import "Primitives.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma mark - PrimitivesRoot

@implementation PrimitivesRoot

@end

#pragma mark - PrimitivesRoot_FileDescriptor

static GPBFileDescriptor *PrimitivesRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"fhirbuffs"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum Gender

GPBEnumDescriptor *Gender_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "Male", .number = Gender_Male },
      { .name = "Female", .number = Gender_Female },
      { .name = "Other", .number = Gender_Other },
      { .name = "Unknown", .number = Gender_Unknown },
    };
    static const char *extraTextFormatInfo = "\004\000$\000\001&\000\002%\000\003\'\000";
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Gender)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:Gender_IsValidValue
                                      extraTextFormatInfo:extraTextFormatInfo];
  }
  return descriptor;
}

BOOL Gender_IsValidValue(int32_t value__) {
  switch (value__) {
    case Gender_Male:
    case Gender_Female:
    case Gender_Other:
    case Gender_Unknown:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Days

GPBEnumDescriptor *Days_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "Sunday", .number = Days_Sunday },
      { .name = "Monday", .number = Days_Monday },
      { .name = "Tueday", .number = Days_Tueday },
      { .name = "Wednesday", .number = Days_Wednesday },
      { .name = "Thursday", .number = Days_Thursday },
      { .name = "Friday", .number = Days_Friday },
      { .name = "Satday", .number = Days_Satday },
    };
    static const char *extraTextFormatInfo = "\007\000&\000\001&\000\002&\000\003)\000\004(\000\005&\000\006&\000";
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Days)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:Days_IsValidValue
                                      extraTextFormatInfo:extraTextFormatInfo];
  }
  return descriptor;
}

BOOL Days_IsValidValue(int32_t value__) {
  switch (value__) {
    case Days_Sunday:
    case Days_Monday:
    case Days_Tueday:
    case Days_Wednesday:
    case Days_Thursday:
    case Days_Friday:
    case Days_Satday:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Date

@implementation Date

@dynamic value;

typedef struct Date__storage_ {
  uint32_t _has_storage_[1];
  uint32_t value;
} Date__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .number = Date_FieldNumber_Value,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed32,
        .offset = offsetof(Date__storage_, value),
        .defaultValue.valueUInt32 = 0U,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Date class]
                                     rootClass:[PrimitivesRoot class]
                                          file:PrimitivesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Date__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Decimal

@implementation Decimal

@dynamic low;
@dynamic high;
@dynamic signScale;

typedef struct Decimal__storage_ {
  uint32_t _has_storage_[1];
  uint32_t high;
  int32_t signScale;
  uint64_t low;
} Decimal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "low",
        .number = Decimal_FieldNumber_Low,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(Decimal__storage_, low),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "high",
        .number = Decimal_FieldNumber_High,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
        .offset = offsetof(Decimal__storage_, high),
        .defaultValue.valueUInt32 = 0U,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "signScale",
        .number = Decimal_FieldNumber_SignScale,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeSInt32,
        .offset = offsetof(Decimal__storage_, signScale),
        .defaultValue.valueInt32 = 0,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\003\t\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Decimal class]
                                     rootClass:[PrimitivesRoot class]
                                          file:PrimitivesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Decimal__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Position

@implementation Position

@dynamic hasLongitude, longitude;
@dynamic hasLatitude, latitude;
@dynamic hasAltitude, altitude;

typedef struct Position__storage_ {
  uint32_t _has_storage_[1];
  Decimal *longitude;
  Decimal *latitude;
  Decimal *altitude;
} Position__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "longitude",
        .number = Position_FieldNumber_Longitude,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Position__storage_, longitude),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Decimal),
        .fieldOptions = NULL,
      },
      {
        .name = "latitude",
        .number = Position_FieldNumber_Latitude,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Position__storage_, latitude),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Decimal),
        .fieldOptions = NULL,
      },
      {
        .name = "altitude",
        .number = Position_FieldNumber_Altitude,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Position__storage_, altitude),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Decimal),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Position class]
                                     rootClass:[PrimitivesRoot class]
                                          file:PrimitivesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Position__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Coding

@implementation Coding

@dynamic system;
@dynamic version;
@dynamic code;
@dynamic display;
@dynamic userSelected;

typedef struct Coding__storage_ {
  uint32_t _has_storage_[1];
  BOOL userSelected;
  NSString *system;
  NSString *version;
  NSString *code;
  NSString *display;
} Coding__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "system",
        .number = Coding_FieldNumber_System,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Coding__storage_, system),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "version",
        .number = Coding_FieldNumber_Version,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Coding__storage_, version),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "code",
        .number = Coding_FieldNumber_Code,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Coding__storage_, code),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "display",
        .number = Coding_FieldNumber_Display,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Coding__storage_, display),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "userSelected",
        .number = Coding_FieldNumber_UserSelected,
        .hasIndex = 4,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
        .offset = offsetof(Coding__storage_, userSelected),
        .defaultValue.valueBool = NO,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\005\014\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Coding class]
                                     rootClass:[PrimitivesRoot class]
                                          file:PrimitivesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Coding__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CodeableConcept

@implementation CodeableConcept

@dynamic codingArray, codingArray_Count;
@dynamic text;

typedef struct CodeableConcept__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *codingArray;
  NSString *text;
} CodeableConcept__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "codingArray",
        .number = CodeableConcept_FieldNumber_CodingArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CodeableConcept__storage_, codingArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Coding),
        .fieldOptions = NULL,
      },
      {
        .name = "text",
        .number = CodeableConcept_FieldNumber_Text,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CodeableConcept__storage_, text),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CodeableConcept class]
                                     rootClass:[PrimitivesRoot class]
                                          file:PrimitivesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CodeableConcept__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Period

@implementation Period

@dynamic hasStart, start;
@dynamic hasEnd, end;

typedef struct Period__storage_ {
  uint32_t _has_storage_[1];
  Date *start;
  Date *end;
} Period__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .number = Period_FieldNumber_Start,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Period__storage_, start),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Date),
        .fieldOptions = NULL,
      },
      {
        .name = "end",
        .number = Period_FieldNumber_End,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Period__storage_, end),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Date),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Period class]
                                     rootClass:[PrimitivesRoot class]
                                          file:PrimitivesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Period__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Address

@implementation Address

@dynamic use;
@dynamic type;
@dynamic text;
@dynamic lineArray, lineArray_Count;
@dynamic city;
@dynamic district;
@dynamic state;
@dynamic postalCode;
@dynamic country;
@dynamic hasPeriod, period;

typedef struct Address__storage_ {
  uint32_t _has_storage_[1];
  Address_AddressUses use;
  Address_AddressTypes type;
  NSString *text;
  NSMutableArray *lineArray;
  NSString *city;
  NSString *district;
  NSString *state;
  NSString *postalCode;
  NSString *country;
  Period *period;
} Address__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "use",
        .number = Address_FieldNumber_Use,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(Address__storage_, use),
        .defaultValue.valueEnum = Address_AddressUses_Home,
        .dataTypeSpecific.enumDescFunc = Address_AddressUses_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "type",
        .number = Address_FieldNumber_Type,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(Address__storage_, type),
        .defaultValue.valueEnum = Address_AddressTypes_Postal,
        .dataTypeSpecific.enumDescFunc = Address_AddressTypes_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "text",
        .number = Address_FieldNumber_Text,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Address__storage_, text),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "lineArray",
        .number = Address_FieldNumber_LineArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Address__storage_, lineArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "city",
        .number = Address_FieldNumber_City,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Address__storage_, city),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "district",
        .number = Address_FieldNumber_District,
        .hasIndex = 5,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Address__storage_, district),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "state",
        .number = Address_FieldNumber_State,
        .hasIndex = 6,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Address__storage_, state),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "postalCode",
        .number = Address_FieldNumber_PostalCode,
        .hasIndex = 7,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Address__storage_, postalCode),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "country",
        .number = Address_FieldNumber_Country,
        .hasIndex = 8,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Address__storage_, country),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "period",
        .number = Address_FieldNumber_Period,
        .hasIndex = 9,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Address__storage_, period),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Period),
        .fieldOptions = NULL,
      },
    };
    static GPBMessageEnumDescription enums[] = {
      { .enumDescriptorFunc = Address_AddressUses_EnumDescriptor },
      { .enumDescriptorFunc = Address_AddressTypes_EnumDescriptor },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\010\n\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Address class]
                                     rootClass:[PrimitivesRoot class]
                                          file:PrimitivesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:enums
                                     enumCount:sizeof(enums) / sizeof(GPBMessageEnumDescription)
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Address__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Address_Use_RawValue(Address *message) {
  GPBDescriptor *descriptor = [Address descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Address_FieldNumber_Use];
  return GPBGetMessageInt32Field(message, field);
}

void SetAddress_Use_RawValue(Address *message, int32_t value) {
  GPBDescriptor *descriptor = [Address descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Address_FieldNumber_Use];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t Address_Type_RawValue(Address *message) {
  GPBDescriptor *descriptor = [Address descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Address_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetAddress_Type_RawValue(Address *message, int32_t value) {
  GPBDescriptor *descriptor = [Address descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Address_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Address_AddressUses

GPBEnumDescriptor *Address_AddressUses_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "Home", .number = Address_AddressUses_Home },
      { .name = "Work", .number = Address_AddressUses_Work },
      { .name = "Temp", .number = Address_AddressUses_Temp },
      { .name = "Old", .number = Address_AddressUses_Old },
    };
    static const char *extraTextFormatInfo = "\004\000$\000\001$\000\002$\000\003#\000";
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Address_AddressUses)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:Address_AddressUses_IsValidValue
                                      extraTextFormatInfo:extraTextFormatInfo];
  }
  return descriptor;
}

BOOL Address_AddressUses_IsValidValue(int32_t value__) {
  switch (value__) {
    case Address_AddressUses_Home:
    case Address_AddressUses_Work:
    case Address_AddressUses_Temp:
    case Address_AddressUses_Old:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Address_AddressTypes

GPBEnumDescriptor *Address_AddressTypes_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "Postal", .number = Address_AddressTypes_Postal },
      { .name = "Physical", .number = Address_AddressTypes_Physical },
      { .name = "Both", .number = Address_AddressTypes_Both },
    };
    static const char *extraTextFormatInfo = "\003\000&\000\001(\000\002$\000";
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Address_AddressTypes)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:Address_AddressTypes_IsValidValue
                                      extraTextFormatInfo:extraTextFormatInfo];
  }
  return descriptor;
}

BOOL Address_AddressTypes_IsValidValue(int32_t value__) {
  switch (value__) {
    case Address_AddressTypes_Postal:
    case Address_AddressTypes_Physical:
    case Address_AddressTypes_Both:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - HumanName

@implementation HumanName

@dynamic use;
@dynamic text;
@dynamic familyArray, familyArray_Count;
@dynamic givenArray, givenArray_Count;
@dynamic prefixArray, prefixArray_Count;
@dynamic suffixArray, suffixArray_Count;
@dynamic hasPeriod, period;

typedef struct HumanName__storage_ {
  uint32_t _has_storage_[1];
  HumanName_HumanNameUses use;
  NSString *text;
  NSMutableArray *familyArray;
  NSMutableArray *givenArray;
  NSMutableArray *prefixArray;
  NSMutableArray *suffixArray;
  Period *period;
} HumanName__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "use",
        .number = HumanName_FieldNumber_Use,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(HumanName__storage_, use),
        .defaultValue.valueEnum = HumanName_HumanNameUses_Usual,
        .dataTypeSpecific.enumDescFunc = HumanName_HumanNameUses_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "text",
        .number = HumanName_FieldNumber_Text,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(HumanName__storage_, text),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "familyArray",
        .number = HumanName_FieldNumber_FamilyArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
        .offset = offsetof(HumanName__storage_, familyArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "givenArray",
        .number = HumanName_FieldNumber_GivenArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
        .offset = offsetof(HumanName__storage_, givenArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "prefixArray",
        .number = HumanName_FieldNumber_PrefixArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
        .offset = offsetof(HumanName__storage_, prefixArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "suffixArray",
        .number = HumanName_FieldNumber_SuffixArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
        .offset = offsetof(HumanName__storage_, suffixArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "period",
        .number = HumanName_FieldNumber_Period,
        .hasIndex = 6,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(HumanName__storage_, period),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Period),
        .fieldOptions = NULL,
      },
    };
    static GPBMessageEnumDescription enums[] = {
      { .enumDescriptorFunc = HumanName_HumanNameUses_EnumDescriptor },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HumanName class]
                                     rootClass:[PrimitivesRoot class]
                                          file:PrimitivesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:enums
                                     enumCount:sizeof(enums) / sizeof(GPBMessageEnumDescription)
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(HumanName__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t HumanName_Use_RawValue(HumanName *message) {
  GPBDescriptor *descriptor = [HumanName descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:HumanName_FieldNumber_Use];
  return GPBGetMessageInt32Field(message, field);
}

void SetHumanName_Use_RawValue(HumanName *message, int32_t value) {
  GPBDescriptor *descriptor = [HumanName descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:HumanName_FieldNumber_Use];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum HumanName_HumanNameUses

GPBEnumDescriptor *HumanName_HumanNameUses_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "Usual", .number = HumanName_HumanNameUses_Usual },
      { .name = "Official", .number = HumanName_HumanNameUses_Official },
      { .name = "Temp", .number = HumanName_HumanNameUses_Temp },
      { .name = "Nickname", .number = HumanName_HumanNameUses_Nickname },
      { .name = "Anonymous", .number = HumanName_HumanNameUses_Anonymous },
      { .name = "Old", .number = HumanName_HumanNameUses_Old },
      { .name = "Maiden", .number = HumanName_HumanNameUses_Maiden },
    };
    static const char *extraTextFormatInfo = "\007\000%\000\001(\000\002$\000\003(\000\004)\000\005#\000\006&\000";
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(HumanName_HumanNameUses)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:HumanName_HumanNameUses_IsValidValue
                                      extraTextFormatInfo:extraTextFormatInfo];
  }
  return descriptor;
}

BOOL HumanName_HumanNameUses_IsValidValue(int32_t value__) {
  switch (value__) {
    case HumanName_HumanNameUses_Usual:
    case HumanName_HumanNameUses_Official:
    case HumanName_HumanNameUses_Temp:
    case HumanName_HumanNameUses_Nickname:
    case HumanName_HumanNameUses_Anonymous:
    case HumanName_HumanNameUses_Old:
    case HumanName_HumanNameUses_Maiden:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ContactPoint

@implementation ContactPoint

@dynamic authorReference;
@dynamic authorString;
@dynamic hasTime, time;
@dynamic text;

typedef struct ContactPoint__storage_ {
  uint32_t _has_storage_[1];
  ContactPoint_AuthorReferences authorReference;
  NSString *authorString;
  Date *time;
  NSString *text;
} ContactPoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "authorReference",
        .number = ContactPoint_FieldNumber_AuthorReference,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(ContactPoint__storage_, authorReference),
        .defaultValue.valueEnum = ContactPoint_AuthorReferences_Practitioner,
        .dataTypeSpecific.enumDescFunc = ContactPoint_AuthorReferences_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "authorString",
        .number = ContactPoint_FieldNumber_AuthorString,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(ContactPoint__storage_, authorString),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "time",
        .number = ContactPoint_FieldNumber_Time,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(ContactPoint__storage_, time),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Date),
        .fieldOptions = NULL,
      },
      {
        .name = "text",
        .number = ContactPoint_FieldNumber_Text,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(ContactPoint__storage_, text),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    static GPBMessageEnumDescription enums[] = {
      { .enumDescriptorFunc = ContactPoint_AuthorReferences_EnumDescriptor },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\002\001\017\000\002\014\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ContactPoint class]
                                     rootClass:[PrimitivesRoot class]
                                          file:PrimitivesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:enums
                                     enumCount:sizeof(enums) / sizeof(GPBMessageEnumDescription)
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(ContactPoint__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ContactPoint_AuthorReference_RawValue(ContactPoint *message) {
  GPBDescriptor *descriptor = [ContactPoint descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ContactPoint_FieldNumber_AuthorReference];
  return GPBGetMessageInt32Field(message, field);
}

void SetContactPoint_AuthorReference_RawValue(ContactPoint *message, int32_t value) {
  GPBDescriptor *descriptor = [ContactPoint descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ContactPoint_FieldNumber_AuthorReference];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum ContactPoint_AuthorReferences

GPBEnumDescriptor *ContactPoint_AuthorReferences_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "Practitioner", .number = ContactPoint_AuthorReferences_Practitioner },
      { .name = "Patient", .number = ContactPoint_AuthorReferences_Patient },
      { .name = "RelatedPerson", .number = ContactPoint_AuthorReferences_RelatedPerson },
      { .name = "Other", .number = ContactPoint_AuthorReferences_Other },
    };
    static const char *extraTextFormatInfo = "\004\000\014\000\001\007\000\002\r\000\003\005\000";
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ContactPoint_AuthorReferences)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:ContactPoint_AuthorReferences_IsValidValue
                                      extraTextFormatInfo:extraTextFormatInfo];
  }
  return descriptor;
}

BOOL ContactPoint_AuthorReferences_IsValidValue(int32_t value__) {
  switch (value__) {
    case ContactPoint_AuthorReferences_Practitioner:
    case ContactPoint_AuthorReferences_Patient:
    case ContactPoint_AuthorReferences_RelatedPerson:
    case ContactPoint_AuthorReferences_Other:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Contact

@implementation Contact

@dynamic hasPurpose, purpose;
@dynamic hasName, name;
@dynamic telecomArray, telecomArray_Count;
@dynamic hasAddress, address;

typedef struct Contact__storage_ {
  uint32_t _has_storage_[1];
  CodeableConcept *purpose;
  HumanName *name;
  NSMutableArray *telecomArray;
  Address *address;
} Contact__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "purpose",
        .number = Contact_FieldNumber_Purpose,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Contact__storage_, purpose),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CodeableConcept),
        .fieldOptions = NULL,
      },
      {
        .name = "name",
        .number = Contact_FieldNumber_Name,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Contact__storage_, name),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(HumanName),
        .fieldOptions = NULL,
      },
      {
        .name = "telecomArray",
        .number = Contact_FieldNumber_TelecomArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Contact__storage_, telecomArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(ContactPoint),
        .fieldOptions = NULL,
      },
      {
        .name = "address",
        .number = Contact_FieldNumber_Address,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Contact__storage_, address),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Address),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Contact class]
                                     rootClass:[PrimitivesRoot class]
                                          file:PrimitivesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Contact__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Identifier

@implementation Identifier

@dynamic use;
@dynamic typeArray, typeArray_Count;
@dynamic system;
@dynamic value;
@dynamic hasPeriod, period;
@dynamic assignerArray, assignerArray_Count;

typedef struct Identifier__storage_ {
  uint32_t _has_storage_[1];
  Identifier_IdentifierUses use;
  NSMutableArray *typeArray;
  NSString *system;
  NSString *value;
  Period *period;
  NSMutableArray *assignerArray;
} Identifier__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "use",
        .number = Identifier_FieldNumber_Use,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(Identifier__storage_, use),
        .defaultValue.valueEnum = Identifier_IdentifierUses_Usual,
        .dataTypeSpecific.enumDescFunc = Identifier_IdentifierUses_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "typeArray",
        .number = Identifier_FieldNumber_TypeArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Identifier__storage_, typeArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CodeableConcept),
        .fieldOptions = NULL,
      },
      {
        .name = "system",
        .number = Identifier_FieldNumber_System,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Identifier__storage_, system),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "value",
        .number = Identifier_FieldNumber_Value,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Identifier__storage_, value),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "period",
        .number = Identifier_FieldNumber_Period,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Identifier__storage_, period),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Period),
        .fieldOptions = NULL,
      },
      {
        .name = "assignerArray",
        .number = Identifier_FieldNumber_AssignerArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Identifier__storage_, assignerArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Organization),
        .fieldOptions = NULL,
      },
    };
    static GPBMessageEnumDescription enums[] = {
      { .enumDescriptorFunc = Identifier_IdentifierUses_EnumDescriptor },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Identifier class]
                                     rootClass:[PrimitivesRoot class]
                                          file:PrimitivesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:enums
                                     enumCount:sizeof(enums) / sizeof(GPBMessageEnumDescription)
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Identifier__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Identifier_Use_RawValue(Identifier *message) {
  GPBDescriptor *descriptor = [Identifier descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Identifier_FieldNumber_Use];
  return GPBGetMessageInt32Field(message, field);
}

void SetIdentifier_Use_RawValue(Identifier *message, int32_t value) {
  GPBDescriptor *descriptor = [Identifier descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Identifier_FieldNumber_Use];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Identifier_IdentifierUses

GPBEnumDescriptor *Identifier_IdentifierUses_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "Usual", .number = Identifier_IdentifierUses_Usual },
      { .name = "Official", .number = Identifier_IdentifierUses_Official },
      { .name = "Temp", .number = Identifier_IdentifierUses_Temp },
      { .name = "Secondary", .number = Identifier_IdentifierUses_Secondary },
      { .name = "Unknown", .number = Identifier_IdentifierUses_Unknown },
      { .name = "Other", .number = Identifier_IdentifierUses_Other },
    };
    static const char *extraTextFormatInfo = "\006\000\005\000\001\010\000\002\004\000\003\t\000\004\007\000\005\005\000";
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Identifier_IdentifierUses)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:Identifier_IdentifierUses_IsValidValue
                                      extraTextFormatInfo:extraTextFormatInfo];
  }
  return descriptor;
}

BOOL Identifier_IdentifierUses_IsValidValue(int32_t value__) {
  switch (value__) {
    case Identifier_IdentifierUses_Usual:
    case Identifier_IdentifierUses_Official:
    case Identifier_IdentifierUses_Temp:
    case Identifier_IdentifierUses_Secondary:
    case Identifier_IdentifierUses_Unknown:
    case Identifier_IdentifierUses_Other:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Organization

@implementation Organization

@dynamic identifierArray, identifierArray_Count;
@dynamic active;
@dynamic hasType, type;
@dynamic name;
@dynamic telecomArray, telecomArray_Count;
@dynamic addressArray, addressArray_Count;
@dynamic hasPartOf, partOf;
@dynamic contactArray, contactArray_Count;

typedef struct Organization__storage_ {
  uint32_t _has_storage_[1];
  BOOL active;
  NSMutableArray *identifierArray;
  CodeableConcept *type;
  NSString *name;
  NSMutableArray *telecomArray;
  NSMutableArray *addressArray;
  Organization *partOf;
  NSMutableArray *contactArray;
} Organization__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifierArray",
        .number = Organization_FieldNumber_IdentifierArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Organization__storage_, identifierArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Identifier),
        .fieldOptions = NULL,
      },
      {
        .name = "active",
        .number = Organization_FieldNumber_Active,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
        .offset = offsetof(Organization__storage_, active),
        .defaultValue.valueBool = NO,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "type",
        .number = Organization_FieldNumber_Type,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Organization__storage_, type),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CodeableConcept),
        .fieldOptions = NULL,
      },
      {
        .name = "name",
        .number = Organization_FieldNumber_Name,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Organization__storage_, name),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "telecomArray",
        .number = Organization_FieldNumber_TelecomArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Organization__storage_, telecomArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(ContactPoint),
        .fieldOptions = NULL,
      },
      {
        .name = "addressArray",
        .number = Organization_FieldNumber_AddressArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Organization__storage_, addressArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Address),
        .fieldOptions = NULL,
      },
      {
        .name = "partOf",
        .number = Organization_FieldNumber_PartOf,
        .hasIndex = 6,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Organization__storage_, partOf),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Organization),
        .fieldOptions = NULL,
      },
      {
        .name = "contactArray",
        .number = Organization_FieldNumber_ContactArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Organization__storage_, contactArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Contact),
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\007\006\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Organization class]
                                     rootClass:[PrimitivesRoot class]
                                          file:PrimitivesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Organization__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Attachment

@implementation Attachment

@dynamic contentType;
@dynamic language;
@dynamic data_p;
@dynamic uRL;
@dynamic size;
@dynamic hash_p;
@dynamic title;
@dynamic hasCreation, creation;

typedef struct Attachment__storage_ {
  uint32_t _has_storage_[1];
  uint32_t size;
  NSString *contentType;
  NSString *language;
  NSData *data_p;
  NSString *uRL;
  NSData *hash_p;
  NSString *title;
  Date *creation;
} Attachment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contentType",
        .number = Attachment_FieldNumber_ContentType,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Attachment__storage_, contentType),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "language",
        .number = Attachment_FieldNumber_Language,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Attachment__storage_, language),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "data_p",
        .number = Attachment_FieldNumber_Data_p,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
        .offset = offsetof(Attachment__storage_, data_p),
        .defaultValue.valueData = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "uRL",
        .number = Attachment_FieldNumber_URL,
        .hasIndex = 3,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Attachment__storage_, uRL),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "size",
        .number = Attachment_FieldNumber_Size,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
        .offset = offsetof(Attachment__storage_, size),
        .defaultValue.valueUInt32 = 0U,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "hash_p",
        .number = Attachment_FieldNumber_Hash_p,
        .hasIndex = 5,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
        .offset = offsetof(Attachment__storage_, hash_p),
        .defaultValue.valueData = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "title",
        .number = Attachment_FieldNumber_Title,
        .hasIndex = 6,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Attachment__storage_, title),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "creation",
        .number = Attachment_FieldNumber_Creation,
        .hasIndex = 7,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Attachment__storage_, creation),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Date),
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\002\001\013\000\004\001!!\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Attachment class]
                                     rootClass:[PrimitivesRoot class]
                                          file:PrimitivesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Attachment__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Link

@implementation Link

@dynamic target;
@dynamic assurance;

typedef struct Link__storage_ {
  uint32_t _has_storage_[1];
  Link_LinkTarget target;
  Link_LinkAssurance assurance;
} Link__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "target",
        .number = Link_FieldNumber_Target,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(Link__storage_, target),
        .defaultValue.valueEnum = Link_LinkTarget_Patient,
        .dataTypeSpecific.enumDescFunc = Link_LinkTarget_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "assurance",
        .number = Link_FieldNumber_Assurance,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(Link__storage_, assurance),
        .defaultValue.valueEnum = Link_LinkAssurance_Unknown,
        .dataTypeSpecific.enumDescFunc = Link_LinkAssurance_EnumDescriptor,
        .fieldOptions = NULL,
      },
    };
    static GPBMessageEnumDescription enums[] = {
      { .enumDescriptorFunc = Link_LinkTarget_EnumDescriptor },
      { .enumDescriptorFunc = Link_LinkAssurance_EnumDescriptor },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Link class]
                                     rootClass:[PrimitivesRoot class]
                                          file:PrimitivesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:enums
                                     enumCount:sizeof(enums) / sizeof(GPBMessageEnumDescription)
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Link__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Link_Target_RawValue(Link *message) {
  GPBDescriptor *descriptor = [Link descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Link_FieldNumber_Target];
  return GPBGetMessageInt32Field(message, field);
}

void SetLink_Target_RawValue(Link *message, int32_t value) {
  GPBDescriptor *descriptor = [Link descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Link_FieldNumber_Target];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t Link_Assurance_RawValue(Link *message) {
  GPBDescriptor *descriptor = [Link descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Link_FieldNumber_Assurance];
  return GPBGetMessageInt32Field(message, field);
}

void SetLink_Assurance_RawValue(Link *message, int32_t value) {
  GPBDescriptor *descriptor = [Link descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Link_FieldNumber_Assurance];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Link_LinkTarget

GPBEnumDescriptor *Link_LinkTarget_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "Patient", .number = Link_LinkTarget_Patient },
      { .name = "Practitioner", .number = Link_LinkTarget_Practitioner },
      { .name = "RelatedPerson", .number = Link_LinkTarget_RelatedPerson },
      { .name = "Person", .number = Link_LinkTarget_Person },
    };
    static const char *extraTextFormatInfo = "\004\000\007\000\001\014\000\002\r\000\003\006\000";
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Link_LinkTarget)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:Link_LinkTarget_IsValidValue
                                      extraTextFormatInfo:extraTextFormatInfo];
  }
  return descriptor;
}

BOOL Link_LinkTarget_IsValidValue(int32_t value__) {
  switch (value__) {
    case Link_LinkTarget_Patient:
    case Link_LinkTarget_Practitioner:
    case Link_LinkTarget_RelatedPerson:
    case Link_LinkTarget_Person:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Link_LinkAssurance

GPBEnumDescriptor *Link_LinkAssurance_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "Unknown", .number = Link_LinkAssurance_Unknown },
      { .name = "Level1", .number = Link_LinkAssurance_Level1 },
      { .name = "Level2", .number = Link_LinkAssurance_Level2 },
      { .name = "Level3", .number = Link_LinkAssurance_Level3 },
      { .name = "Level4", .number = Link_LinkAssurance_Level4 },
    };
    static const char *extraTextFormatInfo = "\005\000\'\000\001&\000\002&\000\003&\000\004&\000";
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Link_LinkAssurance)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:Link_LinkAssurance_IsValidValue
                                      extraTextFormatInfo:extraTextFormatInfo];
  }
  return descriptor;
}

BOOL Link_LinkAssurance_IsValidValue(int32_t value__) {
  switch (value__) {
    case Link_LinkAssurance_Unknown:
    case Link_LinkAssurance_Level1:
    case Link_LinkAssurance_Level2:
    case Link_LinkAssurance_Level3:
    case Link_LinkAssurance_Level4:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Quantity

@implementation Quantity

@dynamic hasValue, value;
@dynamic comparator;
@dynamic unit;
@dynamic system;
@dynamic code;

typedef struct Quantity__storage_ {
  uint32_t _has_storage_[1];
  Decimal *value;
  NSString *comparator;
  NSString *unit;
  NSString *system;
  NSString *code;
} Quantity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .number = Quantity_FieldNumber_Value,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Quantity__storage_, value),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Decimal),
        .fieldOptions = NULL,
      },
      {
        .name = "comparator",
        .number = Quantity_FieldNumber_Comparator,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Quantity__storage_, comparator),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "unit",
        .number = Quantity_FieldNumber_Unit,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Quantity__storage_, unit),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "system",
        .number = Quantity_FieldNumber_System,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Quantity__storage_, system),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "code",
        .number = Quantity_FieldNumber_Code,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(Quantity__storage_, code),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Quantity class]
                                     rootClass:[PrimitivesRoot class]
                                          file:PrimitivesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Quantity__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Ratio

@implementation Ratio

@dynamic hasNumerator, numerator;
@dynamic hasDenominator, denominator;

typedef struct Ratio__storage_ {
  uint32_t _has_storage_[1];
  Quantity *numerator;
  Quantity *denominator;
} Ratio__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "numerator",
        .number = Ratio_FieldNumber_Numerator,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Ratio__storage_, numerator),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Quantity),
        .fieldOptions = NULL,
      },
      {
        .name = "denominator",
        .number = Ratio_FieldNumber_Denominator,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Ratio__storage_, denominator),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Quantity),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Ratio class]
                                     rootClass:[PrimitivesRoot class]
                                          file:PrimitivesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Ratio__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Instance

@implementation Instance

@dynamic hasIdentifier, identifier;
@dynamic hasExpiry, expiry;
@dynamic hasQuantity, quantity;

typedef struct Instance__storage_ {
  uint32_t _has_storage_[1];
  Identifier *identifier;
  Date *expiry;
  Quantity *quantity;
} Instance__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .number = Instance_FieldNumber_Identifier,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Instance__storage_, identifier),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Identifier),
        .fieldOptions = NULL,
      },
      {
        .name = "expiry",
        .number = Instance_FieldNumber_Expiry,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Instance__storage_, expiry),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Date),
        .fieldOptions = NULL,
      },
      {
        .name = "quantity",
        .number = Instance_FieldNumber_Quantity,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Instance__storage_, quantity),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Quantity),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Instance class]
                                     rootClass:[PrimitivesRoot class]
                                          file:PrimitivesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Instance__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceType

@implementation ServiceType

@dynamic hasType, type;
@dynamic hasSpecialty, specialty;

typedef struct ServiceType__storage_ {
  uint32_t _has_storage_[1];
  CodeableConcept *type;
  CodeableConcept *specialty;
} ServiceType__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .number = ServiceType_FieldNumber_Type,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(ServiceType__storage_, type),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CodeableConcept),
        .fieldOptions = NULL,
      },
      {
        .name = "specialty",
        .number = ServiceType_FieldNumber_Specialty,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(ServiceType__storage_, specialty),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CodeableConcept),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceType class]
                                     rootClass:[PrimitivesRoot class]
                                          file:PrimitivesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(ServiceType__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AvailableTime

@implementation AvailableTime

@dynamic daysOfWeek;
@dynamic allDay;
@dynamic availableStartTime;
@dynamic availableEndTime;

typedef struct AvailableTime__storage_ {
  uint32_t _has_storage_[1];
  BOOL allDay;
  Days daysOfWeek;
  uint32_t availableStartTime;
  uint32_t availableEndTime;
} AvailableTime__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "daysOfWeek",
        .number = AvailableTime_FieldNumber_DaysOfWeek,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(AvailableTime__storage_, daysOfWeek),
        .defaultValue.valueEnum = Days_Sunday,
        .dataTypeSpecific.enumDescFunc = Days_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "allDay",
        .number = AvailableTime_FieldNumber_AllDay,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
        .offset = offsetof(AvailableTime__storage_, allDay),
        .defaultValue.valueBool = NO,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "availableStartTime",
        .number = AvailableTime_FieldNumber_AvailableStartTime,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt32,
        .offset = offsetof(AvailableTime__storage_, availableStartTime),
        .defaultValue.valueUInt32 = 0U,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "availableEndTime",
        .number = AvailableTime_FieldNumber_AvailableEndTime,
        .hasIndex = 3,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt32,
        .offset = offsetof(AvailableTime__storage_, availableEndTime),
        .defaultValue.valueUInt32 = 0U,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\004\001\n\000\002\006\000\003\022\000\004\020\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AvailableTime class]
                                     rootClass:[PrimitivesRoot class]
                                          file:PrimitivesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(AvailableTime__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AvailableTime_DaysOfWeek_RawValue(AvailableTime *message) {
  GPBDescriptor *descriptor = [AvailableTime descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AvailableTime_FieldNumber_DaysOfWeek];
  return GPBGetMessageInt32Field(message, field);
}

void SetAvailableTime_DaysOfWeek_RawValue(AvailableTime *message, int32_t value) {
  GPBDescriptor *descriptor = [AvailableTime descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AvailableTime_FieldNumber_DaysOfWeek];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - NotAvailableTime

@implementation NotAvailableTime

@dynamic daysOfWeek;
@dynamic allDay;
@dynamic availableStartTime;
@dynamic availableEndTime;

typedef struct NotAvailableTime__storage_ {
  uint32_t _has_storage_[1];
  BOOL allDay;
  Days daysOfWeek;
  uint32_t availableStartTime;
  uint32_t availableEndTime;
} NotAvailableTime__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "daysOfWeek",
        .number = NotAvailableTime_FieldNumber_DaysOfWeek,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(NotAvailableTime__storage_, daysOfWeek),
        .defaultValue.valueEnum = Days_Sunday,
        .dataTypeSpecific.enumDescFunc = Days_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "allDay",
        .number = NotAvailableTime_FieldNumber_AllDay,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
        .offset = offsetof(NotAvailableTime__storage_, allDay),
        .defaultValue.valueBool = NO,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "availableStartTime",
        .number = NotAvailableTime_FieldNumber_AvailableStartTime,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt32,
        .offset = offsetof(NotAvailableTime__storage_, availableStartTime),
        .defaultValue.valueUInt32 = 0U,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "availableEndTime",
        .number = NotAvailableTime_FieldNumber_AvailableEndTime,
        .hasIndex = 3,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt32,
        .offset = offsetof(NotAvailableTime__storage_, availableEndTime),
        .defaultValue.valueUInt32 = 0U,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\004\001\n\000\002\006\000\003\022\000\004\020\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NotAvailableTime class]
                                     rootClass:[PrimitivesRoot class]
                                          file:PrimitivesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(NotAvailableTime__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t NotAvailableTime_DaysOfWeek_RawValue(NotAvailableTime *message) {
  GPBDescriptor *descriptor = [NotAvailableTime descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NotAvailableTime_FieldNumber_DaysOfWeek];
  return GPBGetMessageInt32Field(message, field);
}

void SetNotAvailableTime_DaysOfWeek_RawValue(NotAvailableTime *message, int32_t value) {
  GPBDescriptor *descriptor = [NotAvailableTime descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NotAvailableTime_FieldNumber_DaysOfWeek];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Qualifications

@implementation Qualifications

@dynamic identifierArray, identifierArray_Count;
@dynamic hasCode, code;
@dynamic hasPeriod, period;
@dynamic hasIssuer, issuer;

typedef struct Qualifications__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *identifierArray;
  CodeableConcept *code;
  Period *period;
  Organization *issuer;
} Qualifications__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifierArray",
        .number = Qualifications_FieldNumber_IdentifierArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Qualifications__storage_, identifierArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Identifier),
        .fieldOptions = NULL,
      },
      {
        .name = "code",
        .number = Qualifications_FieldNumber_Code,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Qualifications__storage_, code),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CodeableConcept),
        .fieldOptions = NULL,
      },
      {
        .name = "period",
        .number = Qualifications_FieldNumber_Period,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Qualifications__storage_, period),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Period),
        .fieldOptions = NULL,
      },
      {
        .name = "issuer",
        .number = Qualifications_FieldNumber_Issuer,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(Qualifications__storage_, issuer),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Organization),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Qualifications class]
                                     rootClass:[PrimitivesRoot class]
                                          file:PrimitivesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(Qualifications__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


// @@protoc_insertion_point(global_scope)
